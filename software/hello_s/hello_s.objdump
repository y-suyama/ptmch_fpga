
hello_s.elf:     file format elf32-littlenios2
hello_s.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00048180

Program Header:
    LOAD off    0x00001000 vaddr 0x00020000 paddr 0x00020000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x
    LOAD off    0x00001020 vaddr 0x00048020 paddr 0x00048020 align 2**12
         filesz 0x0000145c memsz 0x00001574 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  00020000  00020000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000160  00048020  00048020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00001144  00048180  00048180  00001180  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000054  000492c4  000492c4  000022c4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00000164  00049318  00049318  00002318  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000118  0004947c  0004947c  0000247c  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_flash_data 00000000  00020020  00020020  0000247c  2**0
                  CONTENTS
  7 .onchip_memory 00000000  00049594  00049594  0000247c  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  0000247c  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00000398  00000000  00000000  000024a0  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   00003f6d  00000000  00000000  00002838  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 000017cb  00000000  00000000  000067a5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000191b  00000000  00000000  00007f70  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  000006d4  00000000  00000000  0000988c  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000017ba  00000000  00000000  00009f60  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00001d7b  00000000  00000000  0000b71a  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000040  00000000  00000000  0000d498  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00000158  00000000  00000000  0000d4d8  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000003  00000000  00000000  0000ec82  2**0
                  CONTENTS, READONLY
 19 .cpu          00000009  00000000  00000000  0000ec85  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  0000ec8e  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  0000ec8f  2**0
                  CONTENTS, READONLY
 22 .stderr_dev   00000009  00000000  00000000  0000ec90  2**0
                  CONTENTS, READONLY
 23 .stdin_dev    00000009  00000000  00000000  0000ec99  2**0
                  CONTENTS, READONLY
 24 .stdout_dev   00000009  00000000  00000000  0000eca2  2**0
                  CONTENTS, READONLY
 25 .sopc_system_name 0000000c  00000000  00000000  0000ecab  2**0
                  CONTENTS, READONLY
 26 .quartus_project_dir 00000043  00000000  00000000  0000ecb7  2**0
                  CONTENTS, READONLY
 27 .jdi          00004f98  00000000  00000000  0000ecfa  2**0
                  CONTENTS, READONLY
 28 .sopcinfo     00067252  00000000  00000000  00013c92  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00020000 l    d  .entry	00000000 .entry
00048020 l    d  .exceptions	00000000 .exceptions
00048180 l    d  .text	00000000 .text
000492c4 l    d  .rodata	00000000 .rodata
00049318 l    d  .rwdata	00000000 .rwdata
0004947c l    d  .bss	00000000 .bss
00020020 l    d  .onchip_flash_data	00000000 .onchip_flash_data
00049594 l    d  .onchip_memory	00000000 .onchip_memory
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../hello_s_bsp//obj/HAL/src/crt0.o
000481b4 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 hello_world_small.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_putstr.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00049418 l     O .rwdata	0000003c modular_adc_0
00049318 l     O .rwdata	00000100 onchip_flash
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_modular_adc.c
0004844c l     F .text	00000058 alt_adc_irq
00000000 l    df *ABS*	00000000 altera_onchip_flash.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 lib2-mul.c
0004948c g     O .bss	00000004 alt_instruction_exception_handler
00020000 g       *ABS*	00000000 __alt_mem_onchip_flash_data
0004835c g     F .text	00000020 adc_stop
000481d0 g     F .text	0000002c alt_main
00049494 g     O .bss	00000100 alt_irq
000481fc g     F .text	00000038 alt_putstr
00049458 g     O .rwdata	00000004 jtag_uart
00048ff8 g     F .text	00000008 altera_nios2_gen2_irq_init
00020000 g     F .entry	00000000 __reset
00048420 g     F .text	00000018 adc_interrupt_disable
00049490 g     O .bss	00000004 errno
000482f0 g     F .text	00000064 altera_modular_adc_init
00049480 g     O .bss	00000004 alt_argv
00051454 g       *ABS*	00000000 _gp
00048b24 g     F .text	0000005c alt_onchip_flash_poll_for_status_write_passed
00048e2c g     F .text	00000074 alt_find_dev
000490a4 g     F .text	00000028 memcpy
000483a4 g     F .text	00000014 adc_set_mode_run_continuously
00049000 g     F .text	00000074 alt_exception_cause_generated_bad_addr
000491e0 g     F .text	00000064 .hidden __udivsi3
000489dc g     F .text	0000005c alt_onchip_flash_poll_for_status_erase_passed
00049464 g     O .rwdata	00000008 altera_onchip_flash_list
0004945c g     O .rwdata	00000008 altera_modular_adc_list
00048dbc g     F .text	00000004 alt_dcache_flush
00048a38 g     F .text	000000ec alt_onchip_flash_erase_block
00049594 g       *ABS*	00000000 __bss_end
00048f90 g     F .text	00000068 alt_iic_isr_register
00048508 g     F .text	00000014 adc_wait_for_interrupt
00048f78 g     F .text	00000018 alt_ic_irq_enabled
00049488 g     O .bss	00000004 alt_irq_active
000480fc g     F .exceptions	00000060 alt_irq_handler
0004838c g     F .text	00000018 adc_set_mode_run_once
00048000 g       *ABS*	00000000 __alt_mem_onchip_memory
0004837c g     F .text	00000010 adc_start
00049244 g     F .text	00000058 .hidden __umodsi3
00049594 g       *ABS*	00000000 end
0004815c g     F .exceptions	00000024 alt_instruction_exception_entry
00050000 g       *ABS*	00000000 __alt_stack_pointer
00048284 g     F .text	00000034 altera_avalon_jtag_uart_write
0004858c g     F .text	00000044 alt_onchip_flash_get_info
00048180 g     F .text	00000038 _start
00048254 g     F .text	00000030 alt_sys_init
0004929c g     F .text	00000028 .hidden __mulsi3
00048d34 g     F .text	00000088 alt_busy_sleep
00049074 g     F .text	00000030 memcmp
00049594 g       *ABS*	00000000 __alt_stack_base
0004840c g     F .text	00000014 adc_interrupt_enable
0004851c g     F .text	00000070 alt_onchip_flash_read
00048dc0 g     F .text	0000006c alt_dev_llist_insert
00049470 g     O .rwdata	00000008 alt_flash_dev_list
0004947c g       *ABS*	00000000 __bss_start
000481b8 g     F .text	00000018 main
0004947c g     O .bss	00000004 alt_envp
000482b8 g     F .text	00000038 alt_adc_word_read
0004946c g     O .rwdata	00000004 alt_errno
00048988 g     F .text	00000054 alt_onchip_flash_poll_for_status_to_go_idle
000490e8 g     F .text	00000084 .hidden __divsi3
00048754 g     F .text	00000234 altera_onchip_flash_init
00048234 g     F .text	00000020 alt_irq_init
00049484 g     O .bss	00000004 alt_argc
00048020 g       .exceptions	00000000 alt_irq_entry
00048b80 g     F .text	000001b4 alt_onchip_flash_write_block
00048f04 g     F .text	00000004 alt_ic_isr_register
0004947c g       *ABS*	00000000 _edata
000485d0 g     F .text	00000184 alt_onchip_flash_write
00049594 g       *ABS*	00000000 _end
00048ea0 g     F .text	00000050 alt_flash_open_dev
000484f8 g     F .text	00000010 adc_interrupt_asserted
00048f40 g     F .text	00000038 alt_ic_irq_disable
00048438 g     F .text	00000014 adc_clear_interrupt_status
00048ef0 g     F .text	00000014 alt_flash_close_dev
0004916c g     F .text	00000074 .hidden __modsi3
00050000 g       *ABS*	00000000 __alt_data_end
00048020 g     F .exceptions	00000000 alt_exception
00049454 g     O .rwdata	00000004 uart
00048354 g     F .text	00000008 altera_modular_adc_open
00020000 g       .entry	00000000 _exit
000490cc g     F .text	0000001c strlen
000483b8 g     F .text	00000054 adc_recalibrate
00049478 g     O .rwdata	00000004 alt_priority_mask
00048f08 g     F .text	00000038 alt_ic_irq_enable
000484a4 g     F .text	00000054 alt_adc_register_callback



Disassembly of section .exceptions:

00048020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
   48020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
   48024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
   48028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
   4802c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
   48030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
   48034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
   48038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
   4803c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
   48040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
   48044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
   48048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
   4804c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
   48050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
   48054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
   48058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
   4805c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
   48060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
   48064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
   48068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
   4806c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
   48070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
   48074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
   48078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
   4807c:	10000326 	beq	r2,zero,4808c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
   48080:	20000226 	beq	r4,zero,4808c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
   48084:	00480fc0 	call	480fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
   48088:	00000706 	br	480a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
   4808c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
   48090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
   48094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
   48098:	004815c0 	call	4815c <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
   4809c:	1000021e 	bne	r2,zero,480a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
   480a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
   480a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
   480a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
   480ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
   480b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
   480b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
   480b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
   480bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
   480c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
   480c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
   480c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
   480cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
   480d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
   480d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
   480d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
   480dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
   480e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
   480e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
   480e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
   480ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
   480f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
   480f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
   480f8:	ef80083a 	eret

000480fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
   480fc:	defffe04 	addi	sp,sp,-8
   48100:	dfc00115 	stw	ra,4(sp)
   48104:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
   48108:	0009313a 	rdctl	r4,ipending
    do
    {
      if (active & mask)
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
   4810c:	04000174 	movhi	r16,5
   48110:	84252504 	addi	r16,r16,-27500

  active = alt_irq_pending ();

  do
  {
    i = 0;
   48114:	0005883a 	mov	r2,zero
    mask = 1;
   48118:	00c00044 	movi	r3,1
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
   4811c:	20ca703a 	and	r5,r4,r3
   48120:	28000b26 	beq	r5,zero,48150 <alt_irq_handler+0x54>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
   48124:	100490fa 	slli	r2,r2,3
   48128:	8085883a 	add	r2,r16,r2
   4812c:	10c00017 	ldw	r3,0(r2)
   48130:	11000117 	ldw	r4,4(r2)
   48134:	183ee83a 	callr	r3
   48138:	0009313a 	rdctl	r4,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
   4813c:	203ff51e 	bne	r4,zero,48114 <_gp+0xffff6cc0>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
   48140:	dfc00117 	ldw	ra,4(sp)
   48144:	dc000017 	ldw	r16,0(sp)
   48148:	dec00204 	addi	sp,sp,8
   4814c:	f800283a 	ret
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
   48150:	18c7883a 	add	r3,r3,r3
      i++;
   48154:	10800044 	addi	r2,r2,1

    } while (1);
   48158:	003ff006 	br	4811c <_gp+0xffff6cc8>

0004815c <alt_instruction_exception_entry>:
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
   4815c:	d0a00e17 	ldw	r2,-32712(gp)
   48160:	10000426 	beq	r2,zero,48174 <alt_instruction_exception_entry+0x18>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
   48164:	200b883a 	mov	r5,r4
   48168:	000d883a 	mov	r6,zero
   4816c:	013fffc4 	movi	r4,-1
   48170:	1000683a 	jmp	r2
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
   48174:	003da03a 	break	0
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
}
   48178:	0005883a 	mov	r2,zero
   4817c:	f800283a 	ret

Disassembly of section .text:

00048180 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
   48180:	06c00174 	movhi	sp,5
    ori sp, sp, %lo(__alt_stack_pointer)
   48184:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
   48188:	06800174 	movhi	gp,5
    ori gp, gp, %lo(_gp)
   4818c:	d6851514 	ori	gp,gp,5204
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
   48190:	00800134 	movhi	r2,4
    ori r2, r2, %lo(__bss_start)
   48194:	10a51f14 	ori	r2,r2,38012

    movhi r3, %hi(__bss_end)
   48198:	00c00134 	movhi	r3,4
    ori r3, r3, %lo(__bss_end)
   4819c:	18e56514 	ori	r3,r3,38292

    beq r2, r3, 1f
   481a0:	10c00326 	beq	r2,r3,481b0 <_start+0x30>

0:
    stw zero, (r2)
   481a4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
   481a8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
   481ac:	10fffd36 	bltu	r2,r3,481a4 <_gp+0xffff6d50>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
   481b0:	00481d00 	call	481d0 <alt_main>

000481b4 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
   481b4:	003fff06 	br	481b4 <_gp+0xffff6d60>

000481b8 <main>:

#include "sys/alt_stdio.h"

int main()
{ 
  alt_putstr("Hello from Nios II!\n");
   481b8:	01000174 	movhi	r4,5
 */

#include "sys/alt_stdio.h"

int main()
{ 
   481bc:	deffff04 	addi	sp,sp,-4
  alt_putstr("Hello from Nios II!\n");
   481c0:	2124b104 	addi	r4,r4,-27964
 */

#include "sys/alt_stdio.h"

int main()
{ 
   481c4:	dfc00015 	stw	ra,0(sp)
  alt_putstr("Hello from Nios II!\n");
   481c8:	00481fc0 	call	481fc <alt_putstr>
   481cc:	003fff06 	br	481cc <_gp+0xffff6d78>

000481d0 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   481d0:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   481d4:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   481d8:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   481dc:	00482340 	call	48234 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
   481e0:	00482540 	call	48254 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
   481e4:	d1a00a17 	ldw	r6,-32728(gp)
   481e8:	d1600b17 	ldw	r5,-32724(gp)
   481ec:	d1200c17 	ldw	r4,-32720(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
   481f0:	dfc00017 	ldw	ra,0(sp)
   481f4:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
   481f8:	00481b81 	jmpi	481b8 <main>

000481fc <alt_putstr>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided fputs() routine.
 */
int 
alt_putstr(const char* str)
{
   481fc:	defffe04 	addi	sp,sp,-8
   48200:	dc000015 	stw	r16,0(sp)
   48204:	dfc00115 	stw	ra,4(sp)
   48208:	2021883a 	mov	r16,r4
#ifdef ALT_SEMIHOSTING
    return write(STDOUT_FILENO,str,strlen(str));
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, str, strlen(str), 0);
   4820c:	00490cc0 	call	490cc <strlen>
   48210:	01000174 	movhi	r4,5
   48214:	000f883a 	mov	r7,zero
   48218:	100d883a 	mov	r6,r2
   4821c:	800b883a 	mov	r5,r16
   48220:	21251604 	addi	r4,r4,-27560
#else
    return fputs(str, stdout);
#endif
#endif
}
   48224:	dfc00117 	ldw	ra,4(sp)
   48228:	dc000017 	ldw	r16,0(sp)
   4822c:	dec00204 	addi	sp,sp,8
#ifdef ALT_SEMIHOSTING
    return write(STDOUT_FILENO,str,strlen(str));
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, str, strlen(str), 0);
   48230:	00482841 	jmpi	48284 <altera_avalon_jtag_uart_write>

00048234 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
   48234:	deffff04 	addi	sp,sp,-4
   48238:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_CPU, nios2_cpu);
   4823c:	0048ff80 	call	48ff8 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
   48240:	00800044 	movi	r2,1
   48244:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
   48248:	dfc00017 	ldw	ra,0(sp)
   4824c:	dec00104 	addi	sp,sp,4
   48250:	f800283a 	ret

00048254 <alt_sys_init>:

void alt_sys_init( void )
{
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_UART_INIT ( UART, uart);
    ALTERA_MODULAR_ADC_INIT ( MODULAR_ADC_0, modular_adc_0);
   48254:	01000174 	movhi	r4,5
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
   48258:	deffff04 	addi	sp,sp,-4
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_UART_INIT ( UART, uart);
    ALTERA_MODULAR_ADC_INIT ( MODULAR_ADC_0, modular_adc_0);
   4825c:	01800084 	movi	r6,2
   48260:	000b883a 	mov	r5,zero
   48264:	21250604 	addi	r4,r4,-27624
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
   48268:	dfc00015 	stw	ra,0(sp)
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_UART_INIT ( UART, uart);
    ALTERA_MODULAR_ADC_INIT ( MODULAR_ADC_0, modular_adc_0);
   4826c:	00482f00 	call	482f0 <altera_modular_adc_init>
    ALTERA_ONCHIP_FLASH_INIT ( ONCHIP_FLASH, onchip_flash);
   48270:	01000174 	movhi	r4,5
   48274:	2124c604 	addi	r4,r4,-27880
}
   48278:	dfc00017 	ldw	ra,0(sp)
   4827c:	dec00104 	addi	sp,sp,4
void alt_sys_init( void )
{
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
    ALTERA_AVALON_UART_INIT ( UART, uart);
    ALTERA_MODULAR_ADC_INIT ( MODULAR_ADC_0, modular_adc_0);
    ALTERA_ONCHIP_FLASH_INIT ( ONCHIP_FLASH, onchip_flash);
   48280:	00487541 	jmpi	48754 <altera_onchip_flash_init>

00048284 <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
   48284:	21000017 	ldw	r4,0(r4)
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
   48288:	3005883a 	mov	r2,r6
  unsigned int base = sp->base;

  const char * end = ptr + count;
   4828c:	298d883a 	add	r6,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
   48290:	21c00104 	addi	r7,r4,4
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
   48294:	2980072e 	bgeu	r5,r6,482b4 <altera_avalon_jtag_uart_write+0x30>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
   48298:	38c00037 	ldwio	r3,0(r7)
   4829c:	18ffffec 	andhi	r3,r3,65535
   482a0:	183ffc26 	beq	r3,zero,48294 <_gp+0xffff6e40>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
   482a4:	28c00007 	ldb	r3,0(r5)
   482a8:	20c00035 	stwio	r3,0(r4)
   482ac:	29400044 	addi	r5,r5,1
   482b0:	003ff806 	br	48294 <_gp+0xffff6e40>

  return count;
}
   482b4:	f800283a 	ret

000482b8 <alt_adc_word_read>:
    alt_u32 word_length = len;
    alt_u32* dest_buf = dest_ptr;
    alt_u32 base = sample_store_base;
     
    /* return -EINVAL if invalid arguments passed into function */
    if(NULL == dest_buf)
   482b8:	28000b26 	beq	r5,zero,482e8 <alt_adc_word_read+0x30>
   482bc:	0005883a 	mov	r2,zero
    	return -EINVAL;
    }

    for(word = 0; word < word_length; word++)
    {
       *dest_buf = IORD_32DIRECT((base + (word * 4)),0);
   482c0:	2149c83a 	sub	r4,r4,r5
    if(NULL == dest_buf)
    {
    	return -EINVAL;
    }

    for(word = 0; word < word_length; word++)
   482c4:	11800626 	beq	r2,r6,482e0 <alt_adc_word_read+0x28>
    {
       *dest_buf = IORD_32DIRECT((base + (word * 4)),0);
   482c8:	2907883a 	add	r3,r5,r4
   482cc:	18c00037 	ldwio	r3,0(r3)
   482d0:	28c00015 	stw	r3,0(r5)
    if(NULL == dest_buf)
    {
    	return -EINVAL;
    }

    for(word = 0; word < word_length; word++)
   482d4:	10800044 	addi	r2,r2,1
    {
       *dest_buf = IORD_32DIRECT((base + (word * 4)),0);

       dest_buf++;
   482d8:	29400104 	addi	r5,r5,4
   482dc:	003ff906 	br	482c4 <_gp+0xffff6e70>
    }

    return 0;
   482e0:	0005883a 	mov	r2,zero
   482e4:	f800283a 	ret
    alt_u32 base = sample_store_base;
     
    /* return -EINVAL if invalid arguments passed into function */
    if(NULL == dest_buf)
    {
    	return -EINVAL;
   482e8:	00bffa84 	movi	r2,-22
       dest_buf++;
    }

    return 0;

}
   482ec:	f800283a 	ret

000482f0 <altera_modular_adc_init>:


void altera_modular_adc_init(alt_modular_adc_dev* dev, alt_32 ic_id, alt_32 irq)
{
   482f0:	defffb04 	addi	sp,sp,-20
   482f4:	dc000115 	stw	r16,4(sp)
   482f8:	2821883a 	mov	r16,r5
    extern alt_llist altera_modular_adc_list;
    alt_dev_llist_insert((alt_dev_llist*) dev, &altera_modular_adc_list);
   482fc:	d1600204 	addi	r5,gp,-32760

}


void altera_modular_adc_init(alt_modular_adc_dev* dev, alt_32 ic_id, alt_32 irq)
{
   48300:	dc800315 	stw	r18,12(sp)
   48304:	dc400215 	stw	r17,8(sp)
   48308:	dfc00415 	stw	ra,16(sp)
   4830c:	2025883a 	mov	r18,r4
   48310:	3023883a 	mov	r17,r6
    extern alt_llist altera_modular_adc_list;
    alt_dev_llist_insert((alt_dev_llist*) dev, &altera_modular_adc_list);
   48314:	0048dc00 	call	48dc0 <alt_dev_llist_insert>
	
	if ((0 <= ic_id) && (0 <= irq))
   48318:	80000816 	blt	r16,zero,4833c <altera_modular_adc_init+0x4c>
   4831c:	88000716 	blt	r17,zero,4833c <altera_modular_adc_init+0x4c>
	{
          /* Install IRQ handler */
	  #ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
              alt_ic_isr_register(ic_id, irq, alt_adc_irq, 
   48320:	01800174 	movhi	r6,5
   48324:	d8000015 	stw	zero,0(sp)
   48328:	900f883a 	mov	r7,r18
   4832c:	31a11304 	addi	r6,r6,-31668
   48330:	880b883a 	mov	r5,r17
   48334:	8009883a 	mov	r4,r16
   48338:	0048f040 	call	48f04 <alt_ic_isr_register>
                      dev, NULL);
          #else
             alt_irq_register(irq, dev, alt_adc_irq);
          #endif 
	}
}
   4833c:	dfc00417 	ldw	ra,16(sp)
   48340:	dc800317 	ldw	r18,12(sp)
   48344:	dc400217 	ldw	r17,8(sp)
   48348:	dc000117 	ldw	r16,4(sp)
   4834c:	dec00504 	addi	sp,sp,20
   48350:	f800283a 	ret

00048354 <altera_modular_adc_open>:
alt_modular_adc_dev* altera_modular_adc_open (const char *name)
{
    alt_modular_adc_dev *dev = NULL;

    /* Find requested device */
    dev = (alt_modular_adc_dev*) alt_find_dev (name, &altera_modular_adc_list);
   48354:	d1600204 	addi	r5,gp,-32760
   48358:	0048e2c1 	jmpi	48e2c <alt_find_dev>

0004835c <adc_stop>:
    return dev;
}

void adc_stop(int sequencer_base)
{
    ALTERA_MODULAR_ADC_SEQUENCER_STOP(sequencer_base);
   4835c:	20c00037 	ldwio	r3,0(r4)
   48360:	00bfff84 	movi	r2,-2
   48364:	1884703a 	and	r2,r3,r2
   48368:	20800035 	stwio	r2,0(r4)
   4836c:	20800037 	ldwio	r2,0(r4)
   48370:	1080004c 	andi	r2,r2,1
   48374:	103ffd1e 	bne	r2,zero,4836c <_gp+0xffff6f18>
}
   48378:	f800283a 	ret

0004837c <adc_start>:

void adc_start(int sequencer_base)
{
    ALTERA_MODULAR_ADC_SEQUENCER_START(sequencer_base);
   4837c:	20800037 	ldwio	r2,0(r4)
   48380:	10800054 	ori	r2,r2,1
   48384:	20800035 	stwio	r2,0(r4)
   48388:	f800283a 	ret

0004838c <adc_set_mode_run_once>:

void adc_set_mode_run_once(int sequencer_base)
{
    /* Note: Stop the ADC before calling this function,
       changing ADC mode while RUN bit is set has no effect. */
    ALTERA_MODULAR_ADC_SEQUENCER_MODE_RUN_ONCE(sequencer_base);
   4838c:	20c00037 	ldwio	r3,0(r4)
   48390:	00bffc44 	movi	r2,-15
   48394:	1884703a 	and	r2,r3,r2
   48398:	10800094 	ori	r2,r2,2
   4839c:	20800035 	stwio	r2,0(r4)
   483a0:	f800283a 	ret

000483a4 <adc_set_mode_run_continuously>:

void adc_set_mode_run_continuously(int sequencer_base)
{
    /* Note: Stop the ADC before calling this function,
       changing ADC mode while RUN bit is set has no effect. */
    ALTERA_MODULAR_ADC_SEQUENCER_MODE_RUN_CONTINUOUSLY(sequencer_base);
   483a4:	20c00037 	ldwio	r3,0(r4)
   483a8:	00bffc44 	movi	r2,-15
   483ac:	1884703a 	and	r2,r3,r2
   483b0:	20800035 	stwio	r2,0(r4)
   483b4:	f800283a 	ret

000483b8 <adc_recalibrate>:
}

void adc_recalibrate(int sequencer_base)
{
   483b8:	defffd04 	addi	sp,sp,-12
   483bc:	dc000015 	stw	r16,0(sp)
   483c0:	2021883a 	mov	r16,r4
   483c4:	dfc00215 	stw	ra,8(sp)
   483c8:	dc400115 	stw	r17,4(sp)
         2. Start the ADC Sequencer Core.
         5. Poll for RUN bit to be clear
         6. Restore CMD register
     */
    alt_u32 backup_cmd_reg;
    backup_cmd_reg = IORD_ALTERA_MODULAR_ADC_SEQUENCER_CMD_REG(sequencer_base);
   483cc:	24400037 	ldwio	r17,0(r4)
    adc_stop(sequencer_base);
   483d0:	004835c0 	call	4835c <adc_stop>
    ALTERA_MODULAR_ADC_SEQUENCER_MODE_RUN_RECALIBRATION(sequencer_base);
   483d4:	80800037 	ldwio	r2,0(r16)
   483d8:	10800394 	ori	r2,r2,14
   483dc:	80800035 	stwio	r2,0(r16)
    adc_start(sequencer_base);
   483e0:	8009883a 	mov	r4,r16
   483e4:	004837c0 	call	4837c <adc_start>
    while(IORD_ALTERA_MODULAR_ADC_SEQUENCER_CMD_REG(sequencer_base)
   483e8:	80800037 	ldwio	r2,0(r16)
   483ec:	1080004c 	andi	r2,r2,1
   483f0:	103ffd1e 	bne	r2,zero,483e8 <_gp+0xffff6f94>
             & ALTERA_MODULAR_ADC_SEQUENCER_CMD_RUN_MSK);
    IOWR_ALTERA_MODULAR_ADC_SEQUENCER_CMD_REG(sequencer_base, backup_cmd_reg);
   483f4:	84400035 	stwio	r17,0(r16)
}
   483f8:	dfc00217 	ldw	ra,8(sp)
   483fc:	dc400117 	ldw	r17,4(sp)
   48400:	dc000017 	ldw	r16,0(sp)
   48404:	dec00304 	addi	sp,sp,12
   48408:	f800283a 	ret

0004840c <adc_interrupt_enable>:

void adc_interrupt_enable(int sample_store_base)
{
    ALTERA_MODULAR_ADC_SAMPLE_STORAGE_IRQ_ENABLE(sample_store_base);
   4840c:	21004004 	addi	r4,r4,256
   48410:	20800037 	ldwio	r2,0(r4)
   48414:	10800054 	ori	r2,r2,1
   48418:	20800035 	stwio	r2,0(r4)
   4841c:	f800283a 	ret

00048420 <adc_interrupt_disable>:
}

void adc_interrupt_disable(int sample_store_base)
{
    ALTERA_MODULAR_ADC_SAMPLE_STORAGE_IRQ_DISABLE(sample_store_base);
   48420:	21004004 	addi	r4,r4,256
   48424:	20c00037 	ldwio	r3,0(r4)
   48428:	00bfff84 	movi	r2,-2
   4842c:	1884703a 	and	r2,r3,r2
   48430:	20800035 	stwio	r2,0(r4)
   48434:	f800283a 	ret

00048438 <adc_clear_interrupt_status>:
}

void adc_clear_interrupt_status(int sample_store_base)
{
    CLEAR_ALTERA_MODULAR_ADC_SAMPLE_STORAGE_IRQ_STATUS(sample_store_base);
   48438:	21004104 	addi	r4,r4,260
   4843c:	20800037 	ldwio	r2,0(r4)
   48440:	10800054 	ori	r2,r2,1
   48444:	20800035 	stwio	r2,0(r4)
   48448:	f800283a 	ret

0004844c <alt_adc_irq>:
static void alt_adc_irq(void *context)
{
    alt_modular_adc_dev *dev = (alt_modular_adc_dev *) context;
    alt_irq_context cpu_sr = 0;

	if(NULL != dev)
   4844c:	20001426 	beq	r4,zero,484a0 <alt_adc_irq+0x54>
 * alt_adc_irq()
 *
 * Interrupt handler for the altera modular adc.
 */
static void alt_adc_irq(void *context)
{
   48450:	defffd04 	addi	sp,sp,-12
   48454:	dc000015 	stw	r16,0(sp)
   48458:	2021883a 	mov	r16,r4
   4845c:	dfc00215 	stw	ra,8(sp)
   48460:	dc400115 	stw	r17,4(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   48464:	0023303a 	rdctl	r17,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   48468:	00bfff84 	movi	r2,-2
   4846c:	8884703a 	and	r2,r17,r2
   48470:	1001703a 	wrctl	status,r2
		* Other interrupts are explicitly disabled if callbacks
		* are registered because there is no guarantee that they are 
		* pre-emption-safe. This allows the driver to support 
		* interrupt pre-emption.
		*/
		if(dev->callback) 
   48474:	20800a17 	ldw	r2,40(r4)
   48478:	10000226 	beq	r2,zero,48484 <alt_adc_irq+0x38>
		{
			dev->callback (dev->callback_context);
   4847c:	21000b17 	ldw	r4,44(r4)
   48480:	103ee83a 	callr	r2
		}
    
		/* clear the IRQ status */
		adc_clear_interrupt_status(dev->sample_store_base);
   48484:	81000c17 	ldw	r4,48(r16)
   48488:	00484380 	call	48438 <adc_clear_interrupt_status>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   4848c:	8801703a 	wrctl	status,r17
	    
		alt_irq_enable_all(cpu_sr);
	}
	
    return;
}
   48490:	dfc00217 	ldw	ra,8(sp)
   48494:	dc400117 	ldw	r17,4(sp)
   48498:	dc000017 	ldw	r16,0(sp)
   4849c:	dec00304 	addi	sp,sp,12
   484a0:	f800283a 	ret

000484a4 <alt_adc_register_callback>:
void alt_adc_register_callback(
	alt_modular_adc_dev *dev,
	alt_adc_callback callback,
	void *context,
	alt_u32 sample_store_base)
{
   484a4:	defffe04 	addi	sp,sp,-8
   484a8:	dc000015 	stw	r16,0(sp)
   484ac:	dfc00115 	stw	ra,4(sp)
    dev->callback         = callback;
   484b0:	21400a15 	stw	r5,40(r4)
    dev->callback_context = context;
   484b4:	21800b15 	stw	r6,44(r4)
    dev->sample_store_base = sample_store_base;
   484b8:	21c00c15 	stw	r7,48(r4)
void alt_adc_register_callback(
	alt_modular_adc_dev *dev,
	alt_adc_callback callback,
	void *context,
	alt_u32 sample_store_base)
{
   484bc:	3821883a 	mov	r16,r7
    dev->callback_context = context;
    dev->sample_store_base = sample_store_base;
	
	if(NULL != callback)
	{
                adc_clear_interrupt_status(sample_store_base);
   484c0:	3809883a 	mov	r4,r7
{
    dev->callback         = callback;
    dev->callback_context = context;
    dev->sample_store_base = sample_store_base;
	
	if(NULL != callback)
   484c4:	28000626 	beq	r5,zero,484e0 <alt_adc_register_callback+0x3c>
	{
                adc_clear_interrupt_status(sample_store_base);
   484c8:	00484380 	call	48438 <adc_clear_interrupt_status>
		adc_interrupt_enable(sample_store_base);
   484cc:	8009883a 	mov	r4,r16
	}
	
    
	
    return ;
}
   484d0:	dfc00117 	ldw	ra,4(sp)
   484d4:	dc000017 	ldw	r16,0(sp)
   484d8:	dec00204 	addi	sp,sp,8
    dev->sample_store_base = sample_store_base;
	
	if(NULL != callback)
	{
                adc_clear_interrupt_status(sample_store_base);
		adc_interrupt_enable(sample_store_base);
   484dc:	004840c1 	jmpi	4840c <adc_interrupt_enable>
	}
	else
	{
		adc_interrupt_disable(sample_store_base);
   484e0:	00484200 	call	48420 <adc_interrupt_disable>
                adc_clear_interrupt_status(sample_store_base);
   484e4:	8009883a 	mov	r4,r16
	}
	
    
	
    return ;
}
   484e8:	dfc00117 	ldw	ra,4(sp)
   484ec:	dc000017 	ldw	r16,0(sp)
   484f0:	dec00204 	addi	sp,sp,8
		adc_interrupt_enable(sample_store_base);
	}
	else
	{
		adc_interrupt_disable(sample_store_base);
                adc_clear_interrupt_status(sample_store_base);
   484f4:	00484381 	jmpi	48438 <adc_clear_interrupt_status>

000484f8 <adc_interrupt_asserted>:
    CLEAR_ALTERA_MODULAR_ADC_SAMPLE_STORAGE_IRQ_STATUS(sample_store_base);
}

int adc_interrupt_asserted(int sample_store_base)
{
    return((READ_ALTERA_MODULAR_ADC_SAMPLE_STORAGE_IRQ_STATUS(sample_store_base)==1) ? -1 : 0);
   484f8:	20804137 	ldwio	r2,260(r4)
   484fc:	1080004c 	andi	r2,r2,1
}
   48500:	0085c83a 	sub	r2,zero,r2
   48504:	f800283a 	ret

00048508 <adc_wait_for_interrupt>:

void adc_wait_for_interrupt(int sample_store_base)
{
    WAIT_FOR_ALTERA_MODULAR_ADC_SAMPLE_STORAGE_IRQ(sample_store_base);
   48508:	21004104 	addi	r4,r4,260
   4850c:	20800037 	ldwio	r2,0(r4)
   48510:	1080004c 	andi	r2,r2,1
   48514:	103ffd26 	beq	r2,zero,4850c <_gp+0xffff70b8>
}
   48518:	f800283a 	ret

0004851c <alt_onchip_flash_read>:
{
    int ret_code = 0;
    alt_onchip_flash_dev* flash = (alt_onchip_flash_dev*)flash_info;

    /* Make sure the input parameters is not outside of this device's range. */
    if ((offset >= flash->dev.length) || ((offset+length) > flash->dev.length)) {
   4851c:	20800b17 	ldw	r2,44(r4)
   48520:	2880140e 	bge	r5,r2,48574 <alt_onchip_flash_read+0x58>
   48524:	29c7883a 	add	r3,r5,r7
   48528:	10c01216 	blt	r2,r3,48574 <alt_onchip_flash_read+0x58>
    alt_flash_dev *flash_info,
    int           offset,
    void          *dest_addr,
    int           length
)
{
   4852c:	defffe04 	addi	sp,sp,-8
   48530:	dc000015 	stw	r16,0(sp)
   48534:	2021883a 	mov	r16,r4
    /* Make sure the input parameters is not outside of this device's range. */
    if ((offset >= flash->dev.length) || ((offset+length) > flash->dev.length)) {
        return -EFAULT;
    }
    
    memcpy(dest_addr, (alt_u8*)flash->dev.base_addr+offset, length);
   48538:	80800a17 	ldw	r2,40(r16)
   4853c:	3009883a 	mov	r4,r6
   48540:	380d883a 	mov	r6,r7
   48544:	114b883a 	add	r5,r2,r5
    alt_flash_dev *flash_info,
    int           offset,
    void          *dest_addr,
    int           length
)
{
   48548:	dfc00115 	stw	ra,4(sp)
    /* Make sure the input parameters is not outside of this device's range. */
    if ((offset >= flash->dev.length) || ((offset+length) > flash->dev.length)) {
        return -EFAULT;
    }
    
    memcpy(dest_addr, (alt_u8*)flash->dev.base_addr+offset, length);
   4854c:	00490a40 	call	490a4 <memcpy>

    if (NULL != flash->csr_base) {
   48550:	80802f17 	ldw	r2,188(r16)
   48554:	1000021e 	bne	r2,zero,48560 <alt_onchip_flash_read+0x44>
    int           offset,
    void          *dest_addr,
    int           length
)
{
    int ret_code = 0;
   48558:	0005883a 	mov	r2,zero
   4855c:	00000706 	br	4857c <alt_onchip_flash_read+0x60>
    }
    
    memcpy(dest_addr, (alt_u8*)flash->dev.base_addr+offset, length);

    if (NULL != flash->csr_base) {
        int read_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_READ_MSK;
   48560:	10800037 	ldwio	r2,0(r2)
        if (read_status != ALTERA_ONCHIP_FLASH_STATUS_READ_PASSED) {
   48564:	1080010c 	andi	r2,r2,4
   48568:	103ffb1e 	bne	r2,zero,48558 <_gp+0xffff7104>
            /* Read failed.  Return error.*/
            ret_code = -EIO;
   4856c:	00bffec4 	movi	r2,-5
   48570:	00000206 	br	4857c <alt_onchip_flash_read+0x60>
    int ret_code = 0;
    alt_onchip_flash_dev* flash = (alt_onchip_flash_dev*)flash_info;

    /* Make sure the input parameters is not outside of this device's range. */
    if ((offset >= flash->dev.length) || ((offset+length) > flash->dev.length)) {
        return -EFAULT;
   48574:	00bffc84 	movi	r2,-14
   48578:	f800283a 	ret
            /* Read failed.  Return error.*/
            ret_code = -EIO;
        }
    }
    return ret_code;
}
   4857c:	dfc00117 	ldw	ra,4(sp)
   48580:	dc000017 	ldw	r16,0(sp)
   48584:	dec00204 	addi	sp,sp,8
   48588:	f800283a 	ret

0004858c <alt_onchip_flash_get_info>:
{
    int ret_code = 0;

    alt_flash_dev* flash = (alt_flash_dev*)fd;

    if (NULL != number_of_regions)
   4858c:	30000226 	beq	r6,zero,48598 <alt_onchip_flash_get_info+0xc>
    {
        /* Pass the number of region to user */
        *number_of_regions = flash->number_of_regions;
   48590:	20800c17 	ldw	r2,48(r4)
   48594:	30800015 	stw	r2,0(r6)
    }

    if (!flash->number_of_regions)
   48598:	20800c17 	ldw	r2,48(r4)
   4859c:	10000626 	beq	r2,zero,485b8 <alt_onchip_flash_get_info+0x2c>
    {
        ret_code = -ENOMEM;
    }
    else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
   485a0:	00c00204 	movi	r3,8
   485a4:	18800616 	blt	r3,r2,485c0 <alt_onchip_flash_get_info+0x34>
    {
        ret_code = -EFAULT;
    }
    else
    {
        if (NULL != info)
   485a8:	28000726 	beq	r5,zero,485c8 <alt_onchip_flash_get_info+0x3c>
        {
            /* Pass the table of erase blocks to user */
            *info = &flash->region_info[0];
   485ac:	21000d04 	addi	r4,r4,52
   485b0:	29000015 	stw	r4,0(r5)
   485b4:	00000406 	br	485c8 <alt_onchip_flash_get_info+0x3c>
        *number_of_regions = flash->number_of_regions;
    }

    if (!flash->number_of_regions)
    {
        ret_code = -ENOMEM;
   485b8:	00bffd04 	movi	r2,-12
   485bc:	f800283a 	ret
    }
    else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
    {
        ret_code = -EFAULT;
   485c0:	00bffc84 	movi	r2,-14
   485c4:	f800283a 	ret
    alt_flash_fd *fd,
    flash_region **info,
    int          *number_of_regions
)
{
    int ret_code = 0;
   485c8:	0005883a 	mov	r2,zero
            *info = &flash->region_info[0];
        }
    }

    return ret_code;
}
   485cc:	f800283a 	ret

000485d0 <alt_onchip_flash_write>:
    int         full_length = length;
    int         start_offset = offset;
    alt_onchip_flash_dev* flash = (alt_onchip_flash_dev*)flash_info;

    /* Make sure the input parameters is not outside of this device's range. */
    if ((offset >= flash->dev.length) || (length > (flash->dev.length - offset)))
   485d0:	20800b17 	ldw	r2,44(r4)
    alt_flash_dev *flash_info,
    int           offset,
    const void    *src_addr,
    int           length
)
{
   485d4:	defff204 	addi	sp,sp,-56
   485d8:	dfc00d15 	stw	ra,52(sp)
   485dc:	df000c15 	stw	fp,48(sp)
   485e0:	ddc00b15 	stw	r23,44(sp)
   485e4:	dd800a15 	stw	r22,40(sp)
   485e8:	dd400915 	stw	r21,36(sp)
   485ec:	dd000815 	stw	r20,32(sp)
   485f0:	dcc00715 	stw	r19,28(sp)
   485f4:	dc800615 	stw	r18,24(sp)
   485f8:	dc400515 	stw	r17,20(sp)
   485fc:	dc000415 	stw	r16,16(sp)
   48600:	d9c00215 	stw	r7,8(sp)
    int         full_length = length;
    int         start_offset = offset;
    alt_onchip_flash_dev* flash = (alt_onchip_flash_dev*)flash_info;

    /* Make sure the input parameters is not outside of this device's range. */
    if ((offset >= flash->dev.length) || (length > (flash->dev.length - offset)))
   48604:	2880460e 	bge	r5,r2,48720 <alt_onchip_flash_write+0x150>
   48608:	1145c83a 	sub	r2,r2,r5
   4860c:	2827883a 	mov	r19,r5
   48610:	11c04316 	blt	r2,r7,48720 <alt_onchip_flash_write+0x150>
   48614:	2023883a 	mov	r17,r4
   48618:	3029883a 	mov	r20,r6
   4861c:	27001004 	addi	fp,r4,64
   48620:	382d883a 	mov	r22,r7
   48624:	2821883a 	mov	r16,r5
   48628:	d8000115 	stw	zero,4(sp)
    }

    /*
    * First and foremost which sectors are affected?
    */
    for(i=0;i<flash->dev.number_of_regions;i++)
   4862c:	88800c17 	ldw	r2,48(r17)
   48630:	d8c00117 	ldw	r3,4(sp)
   48634:	1880320e 	bge	r3,r2,48700 <alt_onchip_flash_write+0x130>
    {
        /* Is it in this erase block region?*/
        if((offset >= flash->dev.region_info[i].offset) &&
   48638:	e4bffd17 	ldw	r18,-12(fp)
   4863c:	84802a16 	blt	r16,r18,486e8 <alt_onchip_flash_write+0x118>
   48640:	e0bffe17 	ldw	r2,-8(fp)
   48644:	9085883a 	add	r2,r18,r2
   48648:	8080270e 	bge	r16,r2,486e8 <alt_onchip_flash_write+0x118>
   4864c:	002f883a 	mov	r23,zero
            (offset < (flash->dev.region_info[i].offset +
            flash->dev.region_info[i].region_size)))
        {
            current_offset = flash->dev.region_info[i].offset;

            for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
   48650:	e0bfff17 	ldw	r2,-4(fp)
   48654:	b880240e 	bge	r23,r2,486e8 <alt_onchip_flash_write+0x118>
            {
                if ((offset >= current_offset ) &&
   48658:	84801f16 	blt	r16,r18,486d8 <alt_onchip_flash_write+0x108>
                    (offset < (current_offset +
   4865c:	e0800017 	ldw	r2,0(fp)
   48660:	9085883a 	add	r2,r18,r2
        {
            current_offset = flash->dev.region_info[i].offset;

            for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
            {
                if ((offset >= current_offset ) &&
   48664:	80801c0e 	bge	r16,r2,486d8 <alt_onchip_flash_write+0x108>
                {
                    /*
                    * Check if the contents of the block are different
                    * from the data we wish to put there
                    */
                    data_to_write = (current_offset + flash->dev.region_info[i].block_size - offset);
   48668:	1405c83a 	sub	r2,r2,r16
                    data_to_write = MIN(data_to_write, length);
   4866c:	b02b883a 	mov	r21,r22
   48670:	1580010e 	bge	r2,r22,48678 <alt_onchip_flash_write+0xa8>
   48674:	102b883a 	mov	r21,r2
                    if(memcmp(src_addr, (alt_u8*)flash->dev.base_addr+offset, data_to_write))
   48678:	89400a17 	ldw	r5,40(r17)
   4867c:	a80d883a 	mov	r6,r21
   48680:	a009883a 	mov	r4,r20
   48684:	2c0b883a 	add	r5,r5,r16
   48688:	00490740 	call	49074 <memcmp>
   4868c:	10001b26 	beq	r2,zero,486fc <alt_onchip_flash_write+0x12c>
                    {
                        ret_code = (*flash->dev.erase_block)(&flash->dev, current_offset);
   48690:	88800817 	ldw	r2,32(r17)
   48694:	900b883a 	mov	r5,r18
   48698:	8809883a 	mov	r4,r17
   4869c:	103ee83a 	callr	r2

                        if (!ret_code)
   486a0:	1000181e 	bne	r2,zero,48704 <alt_onchip_flash_write+0x134>
                        {
                            ret_code = (*flash->dev.write_block)(
   486a4:	dd400015 	stw	r21,0(sp)
   486a8:	88800917 	ldw	r2,36(r17)
   486ac:	a00f883a 	mov	r7,r20
   486b0:	800d883a 	mov	r6,r16
   486b4:	900b883a 	mov	r5,r18
   486b8:	8809883a 	mov	r4,r17
   486bc:	103ee83a 	callr	r2
                                                                data_to_write);
                        }
                    }

                    /* Was this the last block? */
                    if ((length == data_to_write) || ret_code)
   486c0:	b5401026 	beq	r22,r21,48704 <alt_onchip_flash_write+0x134>
   486c4:	10000f1e 	bne	r2,zero,48704 <alt_onchip_flash_write+0x134>
                    {
                        goto finished;
                    }

                    length -= data_to_write;
                    offset = current_offset + flash->dev.region_info[i].block_size;
   486c8:	e4000017 	ldw	r16,0(fp)
                    if ((length == data_to_write) || ret_code)
                    {
                        goto finished;
                    }

                    length -= data_to_write;
   486cc:	b56dc83a 	sub	r22,r22,r21
                    offset = current_offset + flash->dev.region_info[i].block_size;
                    src_addr = (alt_u8*)src_addr + data_to_write;
   486d0:	a569883a 	add	r20,r20,r21
                    {
                        goto finished;
                    }

                    length -= data_to_write;
                    offset = current_offset + flash->dev.region_info[i].block_size;
   486d4:	9421883a 	add	r16,r18,r16
                    src_addr = (alt_u8*)src_addr + data_to_write;
                }
                current_offset += flash->dev.region_info[i].block_size;
   486d8:	e0800017 	ldw	r2,0(fp)
            (offset < (flash->dev.region_info[i].offset +
            flash->dev.region_info[i].region_size)))
        {
            current_offset = flash->dev.region_info[i].offset;

            for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
   486dc:	bdc00044 	addi	r23,r23,1

                    length -= data_to_write;
                    offset = current_offset + flash->dev.region_info[i].block_size;
                    src_addr = (alt_u8*)src_addr + data_to_write;
                }
                current_offset += flash->dev.region_info[i].block_size;
   486e0:	90a5883a 	add	r18,r18,r2
   486e4:	003fda06 	br	48650 <_gp+0xffff71fc>
    }

    /*
    * First and foremost which sectors are affected?
    */
    for(i=0;i<flash->dev.number_of_regions;i++)
   486e8:	d8c00117 	ldw	r3,4(sp)
   486ec:	e7000404 	addi	fp,fp,16
   486f0:	18c00044 	addi	r3,r3,1
   486f4:	d8c00115 	stw	r3,4(sp)
   486f8:	003fcc06 	br	4862c <_gp+0xffff71d8>
                                                                data_to_write);
                        }
                    }

                    /* Was this the last block? */
                    if ((length == data_to_write) || ret_code)
   486fc:	b57ff21e 	bne	r22,r21,486c8 <_gp+0xffff7274>
    int         full_length = length;
    int         start_offset = offset;
    alt_onchip_flash_dev* flash = (alt_onchip_flash_dev*)flash_info;

    /* Make sure the input parameters is not outside of this device's range. */
    if ((offset >= flash->dev.length) || (length > (flash->dev.length - offset)))
   48700:	0005883a 	mov	r2,zero
            }
        }
    }

finished:
    alt_dcache_flush((alt_u8*)flash->dev.base_addr+start_offset, full_length);
   48704:	89000a17 	ldw	r4,40(r17)
   48708:	d9400217 	ldw	r5,8(sp)
   4870c:	d8800315 	stw	r2,12(sp)
   48710:	24c9883a 	add	r4,r4,r19
   48714:	0048dbc0 	call	48dbc <alt_dcache_flush>
    return ret_code;
   48718:	d8800317 	ldw	r2,12(sp)
   4871c:	00000106 	br	48724 <alt_onchip_flash_write+0x154>
    alt_onchip_flash_dev* flash = (alt_onchip_flash_dev*)flash_info;

    /* Make sure the input parameters is not outside of this device's range. */
    if ((offset >= flash->dev.length) || (length > (flash->dev.length - offset)))
    {
        return -EFAULT;
   48720:	00bffc84 	movi	r2,-14
    }

finished:
    alt_dcache_flush((alt_u8*)flash->dev.base_addr+start_offset, full_length);
    return ret_code;
}
   48724:	dfc00d17 	ldw	ra,52(sp)
   48728:	df000c17 	ldw	fp,48(sp)
   4872c:	ddc00b17 	ldw	r23,44(sp)
   48730:	dd800a17 	ldw	r22,40(sp)
   48734:	dd400917 	ldw	r21,36(sp)
   48738:	dd000817 	ldw	r20,32(sp)
   4873c:	dcc00717 	ldw	r19,28(sp)
   48740:	dc800617 	ldw	r18,24(sp)
   48744:	dc400517 	ldw	r17,20(sp)
   48748:	dc000417 	ldw	r16,16(sp)
   4874c:	dec00e04 	addi	sp,sp,56
   48750:	f800283a 	ret

00048754 <altera_onchip_flash_init>:

    /* Set up flash_region data structures. */
    number_of_regions = 0;
    region_info = &flash->dev.region_info[0];

    if (flash->csr_base != NULL) {
   48754:	20802f17 	ldw	r2,188(r4)
**/
void altera_onchip_flash_init
(
    alt_onchip_flash_dev *flash
)
{
   48758:	defff704 	addi	sp,sp,-36
   4875c:	dc800215 	stw	r18,8(sp)
   48760:	dc000015 	stw	r16,0(sp)
   48764:	dfc00815 	stw	ra,32(sp)
   48768:	ddc00715 	stw	r23,28(sp)
   4876c:	dd800615 	stw	r22,24(sp)
   48770:	dd400515 	stw	r21,20(sp)
   48774:	dd000415 	stw	r20,16(sp)
   48778:	dcc00315 	stw	r19,12(sp)
   4877c:	dc400115 	stw	r17,4(sp)
   48780:	2021883a 	mov	r16,r4
    int sector4_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_AVAILABLE;
    int sector5_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_AVAILABLE;

    /* Set up flash_region data structures. */
    number_of_regions = 0;
    region_info = &flash->dev.region_info[0];
   48784:	24800d04 	addi	r18,r4,52

    if (flash->csr_base != NULL) {
   48788:	10000b26 	beq	r2,zero,487b8 <altera_onchip_flash_init+0x64>
        sector1_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR1_MSK;
   4878c:	10c00037 	ldwio	r3,0(r2)
   48790:	18c0080c 	andi	r3,r3,32
        sector2_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_MSK;
   48794:	15800037 	ldwio	r22,0(r2)
   48798:	b580100c 	andi	r22,r22,64
        sector3_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_MSK;
   4879c:	15000037 	ldwio	r20,0(r2)
   487a0:	a500200c 	andi	r20,r20,128
        sector4_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_MSK;
   487a4:	14c00037 	ldwio	r19,0(r2)
   487a8:	9cc0400c 	andi	r19,r19,256
        sector5_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_MSK;
   487ac:	15400037 	ldwio	r21,0(r2)
   487b0:	ad40800c 	andi	r21,r21,512
   487b4:	00000506 	br	487cc <altera_onchip_flash_init+0x78>
    flash_region* region_info;
    int sector1_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR1_AVAILABLE;
    int sector2_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_AVAILABLE;
    int sector3_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_AVAILABLE;
    int sector4_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_AVAILABLE;
    int sector5_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_AVAILABLE;
   487b8:	002b883a 	mov	r21,zero
    int number_of_regions;
    flash_region* region_info;
    int sector1_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR1_AVAILABLE;
    int sector2_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_AVAILABLE;
    int sector3_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_AVAILABLE;
    int sector4_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_AVAILABLE;
   487bc:	0027883a 	mov	r19,zero
    /* A region is a sector of the onchip flash */
    int number_of_regions;
    flash_region* region_info;
    int sector1_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR1_AVAILABLE;
    int sector2_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_AVAILABLE;
    int sector3_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_AVAILABLE;
   487c0:	0029883a 	mov	r20,zero
{
    /* A region is a sector of the onchip flash */
    int number_of_regions;
    flash_region* region_info;
    int sector1_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR1_AVAILABLE;
    int sector2_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_AVAILABLE;
   487c4:	002d883a 	mov	r22,zero
)
{
    /* A region is a sector of the onchip flash */
    int number_of_regions;
    flash_region* region_info;
    int sector1_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR1_AVAILABLE;
   487c8:	0007883a 	mov	r3,zero
        sector3_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_MSK;
        sector4_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_MSK;
        sector5_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_MSK;
    }

    if ((flash->sector1_enabled == 1) && (sector1_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR1_UNAVAILABLE)) {
   487cc:	84403017 	ldw	r17,192(r16)
   487d0:	00800044 	movi	r2,1
   487d4:	88800d1e 	bne	r17,r2,4880c <altera_onchip_flash_init+0xb8>
   487d8:	18000c1e 	bne	r3,zero,4880c <altera_onchip_flash_init+0xb8>

        region_info[number_of_regions].offset = flash->sector1_start_addr;
   487dc:	81003117 	ldw	r4,196(r16)
        region_info[number_of_regions].region_size = flash->sector1_end_addr - flash->sector1_start_addr + 1;
   487e0:	80803217 	ldw	r2,200(r16)
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
   487e4:	85c03f17 	ldw	r23,252(r16)
        sector5_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_MSK;
    }

    if ((flash->sector1_enabled == 1) && (sector1_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR1_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector1_start_addr;
   487e8:	81000d15 	stw	r4,52(r16)
        region_info[number_of_regions].region_size = flash->sector1_end_addr - flash->sector1_start_addr + 1;
   487ec:	1109c83a 	sub	r4,r2,r4
   487f0:	21000044 	addi	r4,r4,1
   487f4:	81000e15 	stw	r4,56(r16)
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
   487f8:	b80b883a 	mov	r5,r23
   487fc:	00490e80 	call	490e8 <__divsi3>
   48800:	80800f15 	stw	r2,60(r16)
        region_info[number_of_regions].block_size = flash->page_size;
   48804:	85c01015 	stw	r23,64(r16)
   48808:	00000106 	br	48810 <altera_onchip_flash_init+0xbc>
    int sector3_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_AVAILABLE;
    int sector4_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_AVAILABLE;
    int sector5_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_AVAILABLE;

    /* Set up flash_region data structures. */
    number_of_regions = 0;
   4880c:	0023883a 	mov	r17,zero
        region_info[number_of_regions].block_size = flash->page_size;

        number_of_regions++;
    }

    if ((flash->sector2_enabled == 1) && (sector2_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_UNAVAILABLE)) {
   48810:	80c03317 	ldw	r3,204(r16)
   48814:	00800044 	movi	r2,1
   48818:	1880111e 	bne	r3,r2,48860 <altera_onchip_flash_init+0x10c>
   4881c:	b000101e 	bne	r22,zero,48860 <altera_onchip_flash_init+0x10c>

        region_info[number_of_regions].offset = flash->sector2_start_addr;
   48820:	81003417 	ldw	r4,208(r16)
        region_info[number_of_regions].region_size = flash->sector2_end_addr - flash->sector2_start_addr + 1;
   48824:	80803517 	ldw	r2,212(r16)
        number_of_regions++;
    }

    if ((flash->sector2_enabled == 1) && (sector2_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector2_start_addr;
   48828:	8806913a 	slli	r3,r17,4
        region_info[number_of_regions].region_size = flash->sector2_end_addr - flash->sector2_start_addr + 1;
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
   4882c:	85c03f17 	ldw	r23,252(r16)
    }

    if ((flash->sector2_enabled == 1) && (sector2_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector2_start_addr;
        region_info[number_of_regions].region_size = flash->sector2_end_addr - flash->sector2_start_addr + 1;
   48830:	1105c83a 	sub	r2,r2,r4
        number_of_regions++;
    }

    if ((flash->sector2_enabled == 1) && (sector2_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector2_start_addr;
   48834:	90ed883a 	add	r22,r18,r3
        region_info[number_of_regions].region_size = flash->sector2_end_addr - flash->sector2_start_addr + 1;
   48838:	10800044 	addi	r2,r2,1
   4883c:	b0800115 	stw	r2,4(r22)
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
   48840:	80c7883a 	add	r3,r16,r3
        number_of_regions++;
    }

    if ((flash->sector2_enabled == 1) && (sector2_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector2_start_addr;
   48844:	b1000015 	stw	r4,0(r22)
        region_info[number_of_regions].region_size = flash->sector2_end_addr - flash->sector2_start_addr + 1;
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
   48848:	19000e17 	ldw	r4,56(r3)
   4884c:	b80b883a 	mov	r5,r23
        region_info[number_of_regions].block_size = flash->page_size;

        number_of_regions++;
   48850:	8c400044 	addi	r17,r17,1

    if ((flash->sector2_enabled == 1) && (sector2_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector2_start_addr;
        region_info[number_of_regions].region_size = flash->sector2_end_addr - flash->sector2_start_addr + 1;
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
   48854:	00490e80 	call	490e8 <__divsi3>
   48858:	b0800215 	stw	r2,8(r22)
        region_info[number_of_regions].block_size = flash->page_size;
   4885c:	b5c00315 	stw	r23,12(r22)

        number_of_regions++;
	}

    if ((flash->sector3_enabled == 1) && (sector3_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_UNAVAILABLE)) {
   48860:	80c03617 	ldw	r3,216(r16)
   48864:	00800044 	movi	r2,1
   48868:	1880111e 	bne	r3,r2,488b0 <altera_onchip_flash_init+0x15c>
   4886c:	a000101e 	bne	r20,zero,488b0 <altera_onchip_flash_init+0x15c>

        region_info[number_of_regions].offset = flash->sector3_start_addr;
   48870:	81003717 	ldw	r4,220(r16)
        region_info[number_of_regions].region_size = flash->sector3_end_addr - flash->sector3_start_addr + 1;
   48874:	80803817 	ldw	r2,224(r16)
        number_of_regions++;
	}

    if ((flash->sector3_enabled == 1) && (sector3_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector3_start_addr;
   48878:	8806913a 	slli	r3,r17,4
        region_info[number_of_regions].region_size = flash->sector3_end_addr - flash->sector3_start_addr + 1;
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
   4887c:	85803f17 	ldw	r22,252(r16)
	}

    if ((flash->sector3_enabled == 1) && (sector3_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector3_start_addr;
        region_info[number_of_regions].region_size = flash->sector3_end_addr - flash->sector3_start_addr + 1;
   48880:	1105c83a 	sub	r2,r2,r4
        number_of_regions++;
	}

    if ((flash->sector3_enabled == 1) && (sector3_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector3_start_addr;
   48884:	90e9883a 	add	r20,r18,r3
        region_info[number_of_regions].region_size = flash->sector3_end_addr - flash->sector3_start_addr + 1;
   48888:	10800044 	addi	r2,r2,1
   4888c:	a0800115 	stw	r2,4(r20)
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
   48890:	80c7883a 	add	r3,r16,r3
        number_of_regions++;
	}

    if ((flash->sector3_enabled == 1) && (sector3_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector3_start_addr;
   48894:	a1000015 	stw	r4,0(r20)
        region_info[number_of_regions].region_size = flash->sector3_end_addr - flash->sector3_start_addr + 1;
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
   48898:	19000e17 	ldw	r4,56(r3)
   4889c:	b00b883a 	mov	r5,r22
        region_info[number_of_regions].block_size = flash->page_size;

        number_of_regions++;
   488a0:	8c400044 	addi	r17,r17,1

    if ((flash->sector3_enabled == 1) && (sector3_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector3_start_addr;
        region_info[number_of_regions].region_size = flash->sector3_end_addr - flash->sector3_start_addr + 1;
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
   488a4:	00490e80 	call	490e8 <__divsi3>
   488a8:	a0800215 	stw	r2,8(r20)
        region_info[number_of_regions].block_size = flash->page_size;
   488ac:	a5800315 	stw	r22,12(r20)

        number_of_regions++;
	}

	if ((flash->sector4_enabled == 1) && (sector4_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_UNAVAILABLE)) {
   488b0:	80c03917 	ldw	r3,228(r16)
   488b4:	00800044 	movi	r2,1
   488b8:	1880111e 	bne	r3,r2,48900 <altera_onchip_flash_init+0x1ac>
   488bc:	9800101e 	bne	r19,zero,48900 <altera_onchip_flash_init+0x1ac>

        region_info[number_of_regions].offset = flash->sector4_start_addr;
   488c0:	81003a17 	ldw	r4,232(r16)
        region_info[number_of_regions].region_size = flash->sector4_end_addr - flash->sector4_start_addr + 1;
   488c4:	80803b17 	ldw	r2,236(r16)
        number_of_regions++;
	}

	if ((flash->sector4_enabled == 1) && (sector4_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector4_start_addr;
   488c8:	8806913a 	slli	r3,r17,4
        region_info[number_of_regions].region_size = flash->sector4_end_addr - flash->sector4_start_addr + 1;
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
   488cc:	85003f17 	ldw	r20,252(r16)
	}

	if ((flash->sector4_enabled == 1) && (sector4_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector4_start_addr;
        region_info[number_of_regions].region_size = flash->sector4_end_addr - flash->sector4_start_addr + 1;
   488d0:	1105c83a 	sub	r2,r2,r4
        number_of_regions++;
	}

	if ((flash->sector4_enabled == 1) && (sector4_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector4_start_addr;
   488d4:	90e7883a 	add	r19,r18,r3
        region_info[number_of_regions].region_size = flash->sector4_end_addr - flash->sector4_start_addr + 1;
   488d8:	10800044 	addi	r2,r2,1
   488dc:	98800115 	stw	r2,4(r19)
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
   488e0:	80c7883a 	add	r3,r16,r3
        number_of_regions++;
	}

	if ((flash->sector4_enabled == 1) && (sector4_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector4_start_addr;
   488e4:	99000015 	stw	r4,0(r19)
        region_info[number_of_regions].region_size = flash->sector4_end_addr - flash->sector4_start_addr + 1;
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
   488e8:	19000e17 	ldw	r4,56(r3)
   488ec:	a00b883a 	mov	r5,r20
        region_info[number_of_regions].block_size = flash->page_size;

        number_of_regions++;
   488f0:	8c400044 	addi	r17,r17,1

	if ((flash->sector4_enabled == 1) && (sector4_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector4_start_addr;
        region_info[number_of_regions].region_size = flash->sector4_end_addr - flash->sector4_start_addr + 1;
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
   488f4:	00490e80 	call	490e8 <__divsi3>
   488f8:	98800215 	stw	r2,8(r19)
        region_info[number_of_regions].block_size = flash->page_size;
   488fc:	9d000315 	stw	r20,12(r19)

        number_of_regions++;
	}

    if ((flash->sector5_enabled == 1) && (sector5_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_UNAVAILABLE)) {
   48900:	80c03c17 	ldw	r3,240(r16)
   48904:	00800044 	movi	r2,1
   48908:	1880111e 	bne	r3,r2,48950 <altera_onchip_flash_init+0x1fc>
   4890c:	a800101e 	bne	r21,zero,48950 <altera_onchip_flash_init+0x1fc>

        region_info[number_of_regions].offset = flash->sector5_start_addr;
   48910:	81003d17 	ldw	r4,244(r16)
        region_info[number_of_regions].region_size = flash->sector5_end_addr - flash->sector5_start_addr + 1;
   48914:	80803e17 	ldw	r2,248(r16)
        number_of_regions++;
	}

    if ((flash->sector5_enabled == 1) && (sector5_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector5_start_addr;
   48918:	8806913a 	slli	r3,r17,4
        region_info[number_of_regions].region_size = flash->sector5_end_addr - flash->sector5_start_addr + 1;
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
   4891c:	84c03f17 	ldw	r19,252(r16)
	}

    if ((flash->sector5_enabled == 1) && (sector5_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector5_start_addr;
        region_info[number_of_regions].region_size = flash->sector5_end_addr - flash->sector5_start_addr + 1;
   48920:	1105c83a 	sub	r2,r2,r4
        number_of_regions++;
	}

    if ((flash->sector5_enabled == 1) && (sector5_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector5_start_addr;
   48924:	90e5883a 	add	r18,r18,r3
        region_info[number_of_regions].region_size = flash->sector5_end_addr - flash->sector5_start_addr + 1;
   48928:	10800044 	addi	r2,r2,1
   4892c:	90800115 	stw	r2,4(r18)
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
   48930:	80c7883a 	add	r3,r16,r3
        number_of_regions++;
	}

    if ((flash->sector5_enabled == 1) && (sector5_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector5_start_addr;
   48934:	91000015 	stw	r4,0(r18)
        region_info[number_of_regions].region_size = flash->sector5_end_addr - flash->sector5_start_addr + 1;
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
   48938:	19000e17 	ldw	r4,56(r3)
   4893c:	980b883a 	mov	r5,r19
        region_info[number_of_regions].block_size = flash->page_size;

        number_of_regions++;
   48940:	8c400044 	addi	r17,r17,1

    if ((flash->sector5_enabled == 1) && (sector5_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_UNAVAILABLE)) {

        region_info[number_of_regions].offset = flash->sector5_start_addr;
        region_info[number_of_regions].region_size = flash->sector5_end_addr - flash->sector5_start_addr + 1;
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
   48944:	00490e80 	call	490e8 <__divsi3>
   48948:	90800215 	stw	r2,8(r18)
        region_info[number_of_regions].block_size = flash->page_size;
   4894c:	94c00315 	stw	r19,12(r18)

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
   48950:	d1600704 	addi	r5,gp,-32740
   48954:	8009883a 	mov	r4,r16

        number_of_regions++;
    }

    /* Update number of regions. */
    flash->dev.number_of_regions = number_of_regions;
   48958:	84400c15 	stw	r17,48(r16)

    /*
    *  Register this device as a valid flash device type
    */
    alt_flash_device_register(&(flash->dev));
}
   4895c:	dfc00817 	ldw	ra,32(sp)
   48960:	ddc00717 	ldw	r23,28(sp)
   48964:	dd800617 	ldw	r22,24(sp)
   48968:	dd400517 	ldw	r21,20(sp)
   4896c:	dd000417 	ldw	r20,16(sp)
   48970:	dcc00317 	ldw	r19,12(sp)
   48974:	dc800217 	ldw	r18,8(sp)
   48978:	dc400117 	ldw	r17,4(sp)
   4897c:	dc000017 	ldw	r16,0(sp)
   48980:	dec00904 	addi	sp,sp,36
   48984:	0048dc01 	jmpi	48dc0 <alt_dev_llist_insert>

00048988 <alt_onchip_flash_poll_for_status_to_go_idle>:
**/
int alt_onchip_flash_poll_for_status_to_go_idle
(
    alt_onchip_flash_dev *flash
)
{
   48988:	defffd04 	addi	sp,sp,-12
   4898c:	dc000015 	stw	r16,0(sp)
    int ret_code = 0;
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;

    while (
   48990:	040002f4 	movhi	r16,11
**/
int alt_onchip_flash_poll_for_status_to_go_idle
(
    alt_onchip_flash_dev *flash
)
{
   48994:	dc400115 	stw	r17,4(sp)
   48998:	dfc00215 	stw	ra,8(sp)
   4899c:	2023883a 	mov	r17,r4
    int ret_code = 0;
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;

    while (
   489a0:	842b9804 	addi	r16,r16,-20896
        (IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) &
   489a4:	88802f17 	ldw	r2,188(r17)
   489a8:	10800037 	ldwio	r2,0(r2)
{
    int ret_code = 0;
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;

    while (
   489ac:	108000cc 	andi	r2,r2,3
   489b0:	10000526 	beq	r2,zero,489c8 <alt_onchip_flash_poll_for_status_to_go_idle+0x40>
        (IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) &
              ALTERA_ONCHIP_FLASH_STATUS_BUSY_MSK
        ) !=  ALTERA_ONCHIP_FLASH_STATUS_BUSY_IDLE
    ) {
	 
	alt_busy_sleep(1); /* delay 1us */
   489b4:	01000044 	movi	r4,1
   489b8:	843fffc4 	addi	r16,r16,-1
   489bc:	0048d340 	call	48d34 <alt_busy_sleep>

        /* If timeout value is zero, it will never timeout. */
        if (timeout != 0) {
            count_down--;
            if (count_down == 0) {
   489c0:	803ff81e 	bne	r16,zero,489a4 <_gp+0xffff7550>
                /* Timeout */
                ret_code = -ETIMEDOUT;
   489c4:	00bfe304 	movi	r2,-116
            }
        }
    }

    return ret_code;
}
   489c8:	dfc00217 	ldw	ra,8(sp)
   489cc:	dc400117 	ldw	r17,4(sp)
   489d0:	dc000017 	ldw	r16,0(sp)
   489d4:	dec00304 	addi	sp,sp,12
   489d8:	f800283a 	ret

000489dc <alt_onchip_flash_poll_for_status_erase_passed>:
**/
int alt_onchip_flash_poll_for_status_erase_passed
(
    alt_onchip_flash_dev *flash
)
{
   489dc:	defffd04 	addi	sp,sp,-12
   489e0:	dc000015 	stw	r16,0(sp)
    int ret_code = 0;
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;

    while (
   489e4:	040002f4 	movhi	r16,11
**/
int alt_onchip_flash_poll_for_status_erase_passed
(
    alt_onchip_flash_dev *flash
)
{
   489e8:	dc400115 	stw	r17,4(sp)
   489ec:	dfc00215 	stw	ra,8(sp)
   489f0:	2023883a 	mov	r17,r4
    int ret_code = 0;
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;

    while (
   489f4:	842b9804 	addi	r16,r16,-20896
        (IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) &
   489f8:	88802f17 	ldw	r2,188(r17)
   489fc:	10800037 	ldwio	r2,0(r2)
{
    int ret_code = 0;
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;

    while (
   48a00:	1080040c 	andi	r2,r2,16
   48a04:	1000061e 	bne	r2,zero,48a20 <alt_onchip_flash_poll_for_status_erase_passed+0x44>
        (IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) &
              ALTERA_ONCHIP_FLASH_STATUS_ERASE_MSK
        ) !=  ALTERA_ONCHIP_FLASH_STATUS_ERASE_PASSED
    ) {

	alt_busy_sleep(1); /* delay 1us */
   48a08:	01000044 	movi	r4,1
   48a0c:	843fffc4 	addi	r16,r16,-1
   48a10:	0048d340 	call	48d34 <alt_busy_sleep>

        /* If timeout value is zero, it will never timeout. */
        if (timeout != 0) {
            count_down--;
            if (count_down == 0) {
   48a14:	803ff81e 	bne	r16,zero,489f8 <_gp+0xffff75a4>
                /* Timeout */
                ret_code = -ETIMEDOUT;
   48a18:	00bfe304 	movi	r2,-116
   48a1c:	00000106 	br	48a24 <alt_onchip_flash_poll_for_status_erase_passed+0x48>
int alt_onchip_flash_poll_for_status_erase_passed
(
    alt_onchip_flash_dev *flash
)
{
    int ret_code = 0;
   48a20:	0005883a 	mov	r2,zero
            }
        }
    }

    return ret_code;
}
   48a24:	dfc00217 	ldw	ra,8(sp)
   48a28:	dc400117 	ldw	r17,4(sp)
   48a2c:	dc000017 	ldw	r16,0(sp)
   48a30:	dec00304 	addi	sp,sp,12
   48a34:	f800283a 	ret

00048a38 <alt_onchip_flash_erase_block>:
    int ret_code = 0;
    alt_onchip_flash_dev *flash = (alt_onchip_flash_dev*)flash_info;
    int page_address;

    /* Make sure the input parameters is not outside of this device's range. */
    if (block_offset >= flash->dev.length) {
   48a38:	20800b17 	ldw	r2,44(r4)
   48a3c:	28802f0e 	bge	r5,r2,48afc <alt_onchip_flash_erase_block+0xc4>
        return -EFAULT;
    }

    /* Make sure IP support write and erase operation */
    if ((flash->csr_base == NULL) || (flash->is_read_only)) {
   48a40:	20802f17 	ldw	r2,188(r4)
int alt_onchip_flash_erase_block
(
    alt_flash_dev *flash_info,
    int           block_offset
)
{
   48a44:	defffd04 	addi	sp,sp,-12
   48a48:	dc400115 	stw	r17,4(sp)
   48a4c:	dfc00215 	stw	ra,8(sp)
   48a50:	dc000015 	stw	r16,0(sp)
   48a54:	2023883a 	mov	r17,r4
    if (block_offset >= flash->dev.length) {
        return -EFAULT;
    }

    /* Make sure IP support write and erase operation */
    if ((flash->csr_base == NULL) || (flash->is_read_only)) {
   48a58:	10002a26 	beq	r2,zero,48b04 <alt_onchip_flash_erase_block+0xcc>
   48a5c:	20802e17 	ldw	r2,184(r4)
   48a60:	1000281e 	bne	r2,zero,48b04 <alt_onchip_flash_erase_block+0xcc>
        return -ENODEV;
    }

    /* The block_offset must be page size aligned */
    if ((block_offset & (flash->page_size - 1)) != 0)
   48a64:	20803f17 	ldw	r2,252(r4)
   48a68:	10bfffc4 	addi	r2,r2,-1
   48a6c:	1144703a 	and	r2,r2,r5
   48a70:	1000261e 	bne	r2,zero,48b0c <alt_onchip_flash_erase_block+0xd4>
   48a74:	2821883a 	mov	r16,r5
        /* The address is not aligned */
        return -EINVAL;
    }

    /* Wait until flash controller idle */
    ret_code = alt_onchip_flash_poll_for_status_to_go_idle(flash);
   48a78:	00489880 	call	48988 <alt_onchip_flash_poll_for_status_to_go_idle>
    if (ret_code != 0)
   48a7c:	1000241e 	bne	r2,zero,48b10 <alt_onchip_flash_erase_block+0xd8>
    {
        return ret_code;
    }

    /* Enable write and erase operation */
    ALTERA_ONCHIP_FLASH_ENABLE_WRITE_AND_ERASE_OPERATION(flash->csr_base);
   48a80:	88802f17 	ldw	r2,188(r17)
   48a84:	10800104 	addi	r2,r2,4
   48a88:	10c00037 	ldwio	r3,0(r2)
   48a8c:	193c002c 	andhi	r4,r3,61440
   48a90:	00c02034 	movhi	r3,128
   48a94:	18ffffc4 	addi	r3,r3,-1
   48a98:	20c6b03a 	or	r3,r4,r3
   48a9c:	10c00035 	stwio	r3,0(r2)

    /* Calculate Page erase address, it is 32bit word addressing*/
    page_address = block_offset / 4;

    /* Perform Page erase operation */
    ALTERA_ONCHIP_FLASH_PAGE_ERASE(flash->csr_base, page_address);
   48aa0:	88c02f17 	ldw	r3,188(r17)
   48aa4:	18c00104 	addi	r3,r3,4
   48aa8:	18800037 	ldwio	r2,0(r3)
   48aac:	800b883a 	mov	r5,r16
   48ab0:	8000010e 	bge	r16,zero,48ab8 <alt_onchip_flash_erase_block+0x80>
   48ab4:	814000c4 	addi	r5,r16,3
   48ab8:	280bd0ba 	srai	r5,r5,2
   48abc:	10bc002c 	andhi	r2,r2,61440
   48ac0:	29401c34 	orhi	r5,r5,112
   48ac4:	288ab03a 	or	r5,r5,r2
   48ac8:	19400035 	stwio	r5,0(r3)

    /* Wait until flash controller idle */
    ret_code = alt_onchip_flash_poll_for_status_to_go_idle(flash);
   48acc:	8809883a 	mov	r4,r17
   48ad0:	00489880 	call	48988 <alt_onchip_flash_poll_for_status_to_go_idle>

    /* Wait until flash controller indicate erase passed */
    ret_code = alt_onchip_flash_poll_for_status_erase_passed(flash);
   48ad4:	8809883a 	mov	r4,r17
   48ad8:	00489dc0 	call	489dc <alt_onchip_flash_poll_for_status_erase_passed>

    /* Disable write and erase operation */
    ALTERA_ONCHIP_FLASH_DISABLE_WRITE_AND_ERASE_OPERATION(flash->csr_base);
   48adc:	88c02f17 	ldw	r3,188(r17)
   48ae0:	18c00104 	addi	r3,r3,4
   48ae4:	19400037 	ldwio	r5,0(r3)
   48ae8:	01040034 	movhi	r4,4096
   48aec:	213fffc4 	addi	r4,r4,-1
   48af0:	2908b03a 	or	r4,r5,r4
   48af4:	19000035 	stwio	r4,0(r3)

    return ret_code;
   48af8:	00000506 	br	48b10 <alt_onchip_flash_erase_block+0xd8>
    alt_onchip_flash_dev *flash = (alt_onchip_flash_dev*)flash_info;
    int page_address;

    /* Make sure the input parameters is not outside of this device's range. */
    if (block_offset >= flash->dev.length) {
        return -EFAULT;
   48afc:	00bffc84 	movi	r2,-14

    /* Disable write and erase operation */
    ALTERA_ONCHIP_FLASH_DISABLE_WRITE_AND_ERASE_OPERATION(flash->csr_base);

    return ret_code;
}
   48b00:	f800283a 	ret
        return -EFAULT;
    }

    /* Make sure IP support write and erase operation */
    if ((flash->csr_base == NULL) || (flash->is_read_only)) {
        return -ENODEV;
   48b04:	00bffb44 	movi	r2,-19
   48b08:	00000106 	br	48b10 <alt_onchip_flash_erase_block+0xd8>

    /* The block_offset must be page size aligned */
    if ((block_offset & (flash->page_size - 1)) != 0)
    {
        /* The address is not aligned */
        return -EINVAL;
   48b0c:	00bffa84 	movi	r2,-22

    /* Disable write and erase operation */
    ALTERA_ONCHIP_FLASH_DISABLE_WRITE_AND_ERASE_OPERATION(flash->csr_base);

    return ret_code;
}
   48b10:	dfc00217 	ldw	ra,8(sp)
   48b14:	dc400117 	ldw	r17,4(sp)
   48b18:	dc000017 	ldw	r16,0(sp)
   48b1c:	dec00304 	addi	sp,sp,12
   48b20:	f800283a 	ret

00048b24 <alt_onchip_flash_poll_for_status_write_passed>:
**/
int alt_onchip_flash_poll_for_status_write_passed
(
    alt_onchip_flash_dev *flash
)
{
   48b24:	defffd04 	addi	sp,sp,-12
   48b28:	dc000015 	stw	r16,0(sp)
    int ret_code = 0;
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;

    while (
   48b2c:	040002f4 	movhi	r16,11
**/
int alt_onchip_flash_poll_for_status_write_passed
(
    alt_onchip_flash_dev *flash
)
{
   48b30:	dc400115 	stw	r17,4(sp)
   48b34:	dfc00215 	stw	ra,8(sp)
   48b38:	2023883a 	mov	r17,r4
    int ret_code = 0;
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;

    while (
   48b3c:	842b9804 	addi	r16,r16,-20896
        (IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) &
   48b40:	88802f17 	ldw	r2,188(r17)
   48b44:	10800037 	ldwio	r2,0(r2)
{
    int ret_code = 0;
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;

    while (
   48b48:	1080020c 	andi	r2,r2,8
   48b4c:	1000061e 	bne	r2,zero,48b68 <alt_onchip_flash_poll_for_status_write_passed+0x44>
        (IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) &
              ALTERA_ONCHIP_FLASH_STATUS_WRITE_MSK
        ) !=  ALTERA_ONCHIP_FLASH_STATUS_WRITE_PASSED
    ) {

	alt_busy_sleep(1); /* delay 1us */
   48b50:	01000044 	movi	r4,1
   48b54:	843fffc4 	addi	r16,r16,-1
   48b58:	0048d340 	call	48d34 <alt_busy_sleep>

        /* If timeout value is zero, it will never timeout. */
        if (timeout != 0) {
            count_down--;
            if (count_down == 0) {
   48b5c:	803ff81e 	bne	r16,zero,48b40 <_gp+0xffff76ec>
                /* Timeout */
                ret_code = -ETIMEDOUT;
   48b60:	00bfe304 	movi	r2,-116
   48b64:	00000106 	br	48b6c <alt_onchip_flash_poll_for_status_write_passed+0x48>
int alt_onchip_flash_poll_for_status_write_passed
(
    alt_onchip_flash_dev *flash
)
{
    int ret_code = 0;
   48b68:	0005883a 	mov	r2,zero
            }
        }
    }

    return ret_code;
}
   48b6c:	dfc00217 	ldw	ra,8(sp)
   48b70:	dc400117 	ldw	r17,4(sp)
   48b74:	dc000017 	ldw	r16,0(sp)
   48b78:	dec00304 	addi	sp,sp,12
   48b7c:	f800283a 	ret

00048b80 <alt_onchip_flash_write_block>:
    int next_data_offset;
    alt_u32 chunk_of_data;

    /* Make sure the input parameters is not outside of this device's range. */
    if (
        (block_offset >= flash->dev.length) ||
   48b80:	20800b17 	ldw	r2,44(r4)
    int           block_offset,
    int           data_offset,
    const void    *data,
    int           length
)
{
   48b84:	defff404 	addi	sp,sp,-48
   48b88:	dc800415 	stw	r18,16(sp)
   48b8c:	dfc00b15 	stw	ra,44(sp)
   48b90:	df000a15 	stw	fp,40(sp)
   48b94:	ddc00915 	stw	r23,36(sp)
   48b98:	dd800815 	stw	r22,32(sp)
   48b9c:	dd400715 	stw	r21,28(sp)
   48ba0:	dd000615 	stw	r20,24(sp)
   48ba4:	dcc00515 	stw	r19,20(sp)
   48ba8:	dc400315 	stw	r17,12(sp)
   48bac:	dc000215 	stw	r16,8(sp)
   48bb0:	dc800c17 	ldw	r18,48(sp)
    int current_data_offset = data_offset;
    int next_data_offset;
    alt_u32 chunk_of_data;

    /* Make sure the input parameters is not outside of this device's range. */
    if (
   48bb4:	28804e0e 	bge	r5,r2,48cf0 <alt_onchip_flash_write_block+0x170>
   48bb8:	3023883a 	mov	r17,r6
        (block_offset >= flash->dev.length) ||
   48bbc:	30804c0e 	bge	r6,r2,48cf0 <alt_onchip_flash_write_block+0x170>
        (data_offset >= flash->dev.length) ||
   48bc0:	1185c83a 	sub	r2,r2,r6
   48bc4:	14804a16 	blt	r2,r18,48cf0 <alt_onchip_flash_write_block+0x170>
    ) {
        return -EFAULT;
    }

    /* Make sure IP support support write and erase operation */
    if ((flash->csr_base == NULL) || (flash->is_read_only != 0)) {
   48bc8:	20802f17 	ldw	r2,188(r4)
   48bcc:	2027883a 	mov	r19,r4
   48bd0:	10004926 	beq	r2,zero,48cf8 <alt_onchip_flash_write_block+0x178>
   48bd4:	20802e17 	ldw	r2,184(r4)
   48bd8:	1000471e 	bne	r2,zero,48cf8 <alt_onchip_flash_write_block+0x178>
   48bdc:	382f883a 	mov	r23,r7
        return -ENODEV;
    }

    /* Wait until flash controller idle */
    ret_code = alt_onchip_flash_poll_for_status_to_go_idle(flash);
   48be0:	00489880 	call	48988 <alt_onchip_flash_poll_for_status_to_go_idle>
   48be4:	1021883a 	mov	r16,r2
    if (ret_code != 0)
   48be8:	1000451e 	bne	r2,zero,48d00 <alt_onchip_flash_write_block+0x180>
    {
        return ret_code;
    }

    /* Enable write and erase operation */
    ALTERA_ONCHIP_FLASH_ENABLE_WRITE_AND_ERASE_OPERATION(flash->csr_base);
   48bec:	98802f17 	ldw	r2,188(r19)
   48bf0:	10800104 	addi	r2,r2,4
   48bf4:	10c00037 	ldwio	r3,0(r2)
   48bf8:	193c002c 	andhi	r4,r3,61440
   48bfc:	00c02034 	movhi	r3,128
   48c00:	18ffffc4 	addi	r3,r3,-1
   48c04:	20c6b03a 	or	r3,r4,r3
   48c08:	10c00035 	stwio	r3,0(r2)
    int           length
)
{
    int ret_code = 0;
    alt_onchip_flash_dev *flash = (alt_onchip_flash_dev*)flash_info;
    int buffer_offset = 0;
   48c0c:	002b883a 	mov	r21,zero

    /* Check data length */
    while (length)
    {
        /* Minimum write size to onchip flash is 32 bits of data */
        chunk_of_data = 0xFFFFFFFF;
   48c10:	073fffc4 	movi	fp,-1
   48c14:	05bfff04 	movi	r22,-4

    /* Enable write and erase operation */
    ALTERA_ONCHIP_FLASH_ENABLE_WRITE_AND_ERASE_OPERATION(flash->csr_base);

    /* Check data length */
    while (length)
   48c18:	90002d26 	beq	r18,zero,48cd0 <alt_onchip_flash_write_block+0x150>
    {
        /* Minimum write size to onchip flash is 32 bits of data */
        chunk_of_data = 0xFFFFFFFF;
   48c1c:	df000015 	stw	fp,0(sp)

        /* The start of data_offset must be 4 bytes (32 bits) aligned */
        if ((current_data_offset & (ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE - 1)) == 0)
   48c20:	890000cc 	andi	r4,r17,3
   48c24:	bd4b883a 	add	r5,r23,r21
   48c28:	20000f1e 	bne	r4,zero,48c68 <alt_onchip_flash_write_block+0xe8>
        {
            /* The address is 4-byte aligned here */
            next_data_offset = (current_data_offset + ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE) & ~(ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE - 1);
   48c2c:	89c00104 	addi	r7,r17,4
   48c30:	3d8e703a 	and	r7,r7,r22
            length_of_current_write = MIN(length, next_data_offset - current_data_offset);
   48c34:	3c69c83a 	sub	r20,r7,r17
   48c38:	9500010e 	bge	r18,r20,48c40 <alt_onchip_flash_write_block+0xc0>
   48c3c:	9029883a 	mov	r20,r18
            /* Prepare the 4 bytes chunk of data to be written */
            memcpy(&chunk_of_data, &((alt_u8*)data)[buffer_offset], length_of_current_write);
   48c40:	a00d883a 	mov	r6,r20
   48c44:	d809883a 	mov	r4,sp
   48c48:	d9c00115 	stw	r7,4(sp)
   48c4c:	00490a40 	call	490a4 <memcpy>

        /* The start of data_offset must be 4 bytes (32 bits) aligned */
        if ((current_data_offset & (ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE - 1)) == 0)
        {
            /* The address is 4-byte aligned here */
            next_data_offset = (current_data_offset + ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE) & ~(ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE - 1);
   48c50:	d9c00117 	ldw	r7,4(sp)
   48c54:	8807883a 	mov	r3,r17
            length_of_current_write = MIN(length, next_data_offset - current_data_offset);
            /* Prepare the 4 bytes chunk of data to be written */
            memcpy(&chunk_of_data, &((alt_u8*)data)[buffer_offset], length_of_current_write);
            buffer_offset += length_of_current_write;
   48c58:	ad2b883a 	add	r21,r21,r20
            length -= length_of_current_write;
   48c5c:	9525c83a 	sub	r18,r18,r20

        /* The start of data_offset must be 4 bytes (32 bits) aligned */
        if ((current_data_offset & (ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE - 1)) == 0)
        {
            /* The address is 4-byte aligned here */
            next_data_offset = (current_data_offset + ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE) & ~(ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE - 1);
   48c60:	3823883a 	mov	r17,r7
   48c64:	00000f06 	br	48ca4 <alt_onchip_flash_write_block+0x124>
        } else {
            /* Calculate how many padding bytes need to be added before the start of a data offset */
            int padding = current_data_offset & (ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE - 1);

            /* Calculate new 4-byte aligned data offset */
            current_data_offset = current_data_offset - padding;
   48c68:	8907c83a 	sub	r3,r17,r4
            next_data_offset = (current_data_offset + ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE) & ~(ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE - 1);
   48c6c:	1c400104 	addi	r17,r3,4
   48c70:	8da2703a 	and	r17,r17,r22
            length_of_current_write = MIN(length + padding, next_data_offset - current_data_offset);
            /* Prepare the 4 bytes chunk of data to be written */
            memcpy((void *)(((int)&chunk_of_data) + (int)padding), &((alt_u8*)data)[buffer_offset], length_of_current_write - padding);
   48c74:	9105883a 	add	r2,r18,r4
   48c78:	88e9c83a 	sub	r20,r17,r3
   48c7c:	1500010e 	bge	r2,r20,48c84 <alt_onchip_flash_write_block+0x104>
   48c80:	1029883a 	mov	r20,r2
   48c84:	a129c83a 	sub	r20,r20,r4
   48c88:	a00d883a 	mov	r6,r20
   48c8c:	d909883a 	add	r4,sp,r4
   48c90:	d8c00115 	stw	r3,4(sp)
   48c94:	00490a40 	call	490a4 <memcpy>
            buffer_offset += length_of_current_write - padding;
            length -= length_of_current_write - padding;
   48c98:	d8c00117 	ldw	r3,4(sp)
            current_data_offset = current_data_offset - padding;
            next_data_offset = (current_data_offset + ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE) & ~(ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE - 1);
            length_of_current_write = MIN(length + padding, next_data_offset - current_data_offset);
            /* Prepare the 4 bytes chunk of data to be written */
            memcpy((void *)(((int)&chunk_of_data) + (int)padding), &((alt_u8*)data)[buffer_offset], length_of_current_write - padding);
            buffer_offset += length_of_current_write - padding;
   48c9c:	ad2b883a 	add	r21,r21,r20
            length -= length_of_current_write - padding;
   48ca0:	9525c83a 	sub	r18,r18,r20
        }

        /* Writing to flash via IO 32 bits at a time */
        IOWR_32DIRECT(flash->dev.base_addr, current_data_offset, chunk_of_data);
   48ca4:	98800a17 	ldw	r2,40(r19)
   48ca8:	10c7883a 	add	r3,r2,r3
   48cac:	d8800017 	ldw	r2,0(sp)
   48cb0:	18800035 	stwio	r2,0(r3)

        /* Wait until flash controller idle */
        ret_code = alt_onchip_flash_poll_for_status_to_go_idle(flash);
   48cb4:	9809883a 	mov	r4,r19
   48cb8:	00489880 	call	48988 <alt_onchip_flash_poll_for_status_to_go_idle>
        if (ret_code != 0)
   48cbc:	1000031e 	bne	r2,zero,48ccc <alt_onchip_flash_write_block+0x14c>
        {
            break;
        }

        /* Wait until flash controller indicate write passed */
        ret_code = alt_onchip_flash_poll_for_status_write_passed(flash);
   48cc0:	9809883a 	mov	r4,r19
   48cc4:	0048b240 	call	48b24 <alt_onchip_flash_poll_for_status_write_passed>
        if (ret_code != 0)
   48cc8:	103fd326 	beq	r2,zero,48c18 <_gp+0xffff77c4>
        {
            break;
        }

        /* Wait until flash controller indicate write passed */
        ret_code = alt_onchip_flash_poll_for_status_write_passed(flash);
   48ccc:	1021883a 	mov	r16,r2
        /* Prepare to write next 4 bytes */
        current_data_offset = next_data_offset;
    }

    /* Disable write and erase operation */
    ALTERA_ONCHIP_FLASH_DISABLE_WRITE_AND_ERASE_OPERATION(flash->csr_base);
   48cd0:	98802f17 	ldw	r2,188(r19)
   48cd4:	10800104 	addi	r2,r2,4
   48cd8:	11000037 	ldwio	r4,0(r2)
   48cdc:	00c40034 	movhi	r3,4096
   48ce0:	18ffffc4 	addi	r3,r3,-1
   48ce4:	20c6b03a 	or	r3,r4,r3
   48ce8:	10c00035 	stwio	r3,0(r2)
   48cec:	00000406 	br	48d00 <alt_onchip_flash_write_block+0x180>
    if (
        (block_offset >= flash->dev.length) ||
        (data_offset >= flash->dev.length) ||
        (length > (flash->dev.length - data_offset))
    ) {
        return -EFAULT;
   48cf0:	00bffc84 	movi	r2,-14
   48cf4:	00000306 	br	48d04 <alt_onchip_flash_write_block+0x184>
    }

    /* Make sure IP support support write and erase operation */
    if ((flash->csr_base == NULL) || (flash->is_read_only != 0)) {
        return -ENODEV;
   48cf8:	00bffb44 	movi	r2,-19
   48cfc:	00000106 	br	48d04 <alt_onchip_flash_write_block+0x184>
   48d00:	8005883a 	mov	r2,r16

    /* Disable write and erase operation */
    ALTERA_ONCHIP_FLASH_DISABLE_WRITE_AND_ERASE_OPERATION(flash->csr_base);

    return ret_code;
}
   48d04:	dfc00b17 	ldw	ra,44(sp)
   48d08:	df000a17 	ldw	fp,40(sp)
   48d0c:	ddc00917 	ldw	r23,36(sp)
   48d10:	dd800817 	ldw	r22,32(sp)
   48d14:	dd400717 	ldw	r21,28(sp)
   48d18:	dd000617 	ldw	r20,24(sp)
   48d1c:	dcc00517 	ldw	r19,20(sp)
   48d20:	dc800417 	ldw	r18,16(sp)
   48d24:	dc400317 	ldw	r17,12(sp)
   48d28:	dc000217 	ldw	r16,8(sp)
   48d2c:	dec00c04 	addi	sp,sp,48
   48d30:	f800283a 	ret

00048d34 <alt_busy_sleep>:
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
   48d34:	0142e8f4 	movhi	r5,2979
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
   48d38:	defffe04 	addi	sp,sp,-8
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
   48d3c:	297a2e84 	addi	r5,r5,-5958
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
   48d40:	dc000015 	stw	r16,0(sp)
   48d44:	dfc00115 	stw	ra,4(sp)
   48d48:	2021883a 	mov	r16,r4
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
   48d4c:	00491e00 	call	491e0 <__udivsi3>
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
   48d50:	10001026 	beq	r2,zero,48d94 <alt_busy_sleep+0x60>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
   48d54:	01600034 	movhi	r5,32768
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
   48d58:	013d1774 	movhi	r4,62557
   48d5c:	0007883a 	mov	r3,zero
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
   48d60:	297fffc4 	addi	r5,r5,-1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
   48d64:	2105d184 	addi	r4,r4,5958
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
   48d68:	297fffc4 	addi	r5,r5,-1
   48d6c:	283ffe1e 	bne	r5,zero,48d68 <_gp+0xffff7914>
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
   48d70:	18c00044 	addi	r3,r3,1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
   48d74:	8121883a 	add	r16,r16,r4
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
   48d78:	18bffb16 	blt	r3,r2,48d68 <_gp+0xffff7914>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
   48d7c:	014002c4 	movi	r5,11
   48d80:	8009883a 	mov	r4,r16
   48d84:	004929c0 	call	4929c <__mulsi3>
   48d88:	10bfffc4 	addi	r2,r2,-1
   48d8c:	103ffe1e 	bne	r2,zero,48d88 <_gp+0xffff7934>
   48d90:	00000506 	br	48da8 <alt_busy_sleep+0x74>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
   48d94:	014002c4 	movi	r5,11
   48d98:	8009883a 	mov	r4,r16
   48d9c:	004929c0 	call	4929c <__mulsi3>
   48da0:	10bfffc4 	addi	r2,r2,-1
   48da4:	00bffe16 	blt	zero,r2,48da0 <_gp+0xffff794c>
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
}
   48da8:	0005883a 	mov	r2,zero
   48dac:	dfc00117 	ldw	ra,4(sp)
   48db0:	dc000017 	ldw	r16,0(sp)
   48db4:	dec00204 	addi	sp,sp,8
   48db8:	f800283a 	ret

00048dbc <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
   48dbc:	f800283a 	ret

00048dc0 <alt_dev_llist_insert>:
{
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
   48dc0:	20000226 	beq	r4,zero,48dcc <alt_dev_llist_insert+0xc>
   48dc4:	20800217 	ldw	r2,8(r4)
   48dc8:	1000101e 	bne	r2,zero,48e0c <alt_dev_llist_insert+0x4c>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
   48dcc:	d0a00617 	ldw	r2,-32744(gp)
   48dd0:	10000926 	beq	r2,zero,48df8 <alt_dev_llist_insert+0x38>
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
   48dd4:	deffff04 	addi	sp,sp,-4
   48dd8:	dfc00015 	stw	ra,0(sp)
   48ddc:	103ee83a 	callr	r2
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
   48de0:	00c00584 	movi	r3,22
   48de4:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
   48de8:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
   48dec:	dfc00017 	ldw	ra,0(sp)
   48df0:	dec00104 	addi	sp,sp,4
   48df4:	f800283a 	ret
   48df8:	d0a00f04 	addi	r2,gp,-32708
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
   48dfc:	00c00584 	movi	r3,22
   48e00:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
   48e04:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
   48e08:	f800283a 	ret

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  entry->next     = list->next;
   48e0c:	28800017 	ldw	r2,0(r5)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
   48e10:	21400115 	stw	r5,4(r4)
  entry->next     = list->next;
   48e14:	20800015 	stw	r2,0(r4)

  list->next->previous = entry;
   48e18:	28800017 	ldw	r2,0(r5)
   48e1c:	11000115 	stw	r4,4(r2)
  list->next           = entry;
   48e20:	29000015 	stw	r4,0(r5)
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
   48e24:	0005883a 	mov	r2,zero
   48e28:	f800283a 	ret

00048e2c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
   48e2c:	defffb04 	addi	sp,sp,-20
   48e30:	dcc00315 	stw	r19,12(sp)
   48e34:	dc800215 	stw	r18,8(sp)
   48e38:	dc400115 	stw	r17,4(sp)
   48e3c:	dc000015 	stw	r16,0(sp)
   48e40:	dfc00415 	stw	ra,16(sp)
   48e44:	2027883a 	mov	r19,r4
   48e48:	2823883a 	mov	r17,r5
  alt_dev* next = (alt_dev*) llist->next;
   48e4c:	2c000017 	ldw	r16,0(r5)
  alt_32 len;

  len  = strlen(name) + 1;
   48e50:	00490cc0 	call	490cc <strlen>
   48e54:	14800044 	addi	r18,r2,1
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   48e58:	84400726 	beq	r16,r17,48e78 <alt_find_dev+0x4c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
   48e5c:	81000217 	ldw	r4,8(r16)
   48e60:	900d883a 	mov	r6,r18
   48e64:	980b883a 	mov	r5,r19
   48e68:	00490740 	call	49074 <memcmp>
   48e6c:	10000426 	beq	r2,zero,48e80 <alt_find_dev+0x54>
    {
      /* match found */

      return next;
    }
    next = (alt_dev*) next->llist.next;
   48e70:	84000017 	ldw	r16,0(r16)
   48e74:	003ff806 	br	48e58 <_gp+0xffff7a04>
  }
  
  /* No match found */
  
  return NULL;
   48e78:	0005883a 	mov	r2,zero
   48e7c:	00000106 	br	48e84 <alt_find_dev+0x58>
   48e80:	8005883a 	mov	r2,r16
}
   48e84:	dfc00417 	ldw	ra,16(sp)
   48e88:	dcc00317 	ldw	r19,12(sp)
   48e8c:	dc800217 	ldw	r18,8(sp)
   48e90:	dc400117 	ldw	r17,4(sp)
   48e94:	dc000017 	ldw	r16,0(sp)
   48e98:	dec00504 	addi	sp,sp,20
   48e9c:	f800283a 	ret

00048ea0 <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
   48ea0:	defffe04 	addi	sp,sp,-8
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
   48ea4:	d1600704 	addi	r5,gp,-32740
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
   48ea8:	dc000015 	stw	r16,0(sp)
   48eac:	dfc00115 	stw	ra,4(sp)
   48eb0:	2021883a 	mov	r16,r4
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
   48eb4:	0048e2c0 	call	48e2c <alt_find_dev>

  if ((dev) && dev->open)
   48eb8:	10000826 	beq	r2,zero,48edc <alt_flash_open_dev+0x3c>
   48ebc:	10c00317 	ldw	r3,12(r2)
   48ec0:	18000726 	beq	r3,zero,48ee0 <alt_flash_open_dev+0x40>
  {
    return dev->open(dev, name);
   48ec4:	800b883a 	mov	r5,r16
   48ec8:	1009883a 	mov	r4,r2
  }

  return dev;
}
   48ecc:	dfc00117 	ldw	ra,4(sp)
   48ed0:	dc000017 	ldw	r16,0(sp)
   48ed4:	dec00204 	addi	sp,sp,8
{
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);

  if ((dev) && dev->open)
  {
    return dev->open(dev, name);
   48ed8:	1800683a 	jmp	r3
   48edc:	0005883a 	mov	r2,zero
  }

  return dev;
}
   48ee0:	dfc00117 	ldw	ra,4(sp)
   48ee4:	dc000017 	ldw	r16,0(sp)
   48ee8:	dec00204 	addi	sp,sp,8
   48eec:	f800283a 	ret

00048ef0 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
  if (fd && fd->close)
   48ef0:	20000326 	beq	r4,zero,48f00 <alt_flash_close_dev+0x10>
   48ef4:	20800417 	ldw	r2,16(r4)
   48ef8:	10000126 	beq	r2,zero,48f00 <alt_flash_close_dev+0x10>
  {
    fd->close(fd);
   48efc:	1000683a 	jmp	r2
   48f00:	f800283a 	ret

00048f04 <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
   48f04:	0048f901 	jmpi	48f90 <alt_iic_isr_register>

00048f08 <alt_ic_irq_enable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   48f08:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   48f0c:	00bfff84 	movi	r2,-2
   48f10:	2084703a 	and	r2,r4,r2
   48f14:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
   48f18:	00c00044 	movi	r3,1
   48f1c:	d0a00d17 	ldw	r2,-32716(gp)
   48f20:	194a983a 	sll	r5,r3,r5
   48f24:	288ab03a 	or	r5,r5,r2
   48f28:	d1600d15 	stw	r5,-32716(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   48f2c:	d0a00d17 	ldw	r2,-32716(gp)
   48f30:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   48f34:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
   48f38:	0005883a 	mov	r2,zero
   48f3c:	f800283a 	ret

00048f40 <alt_ic_irq_disable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   48f40:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   48f44:	00bfff84 	movi	r2,-2
   48f48:	2084703a 	and	r2,r4,r2
   48f4c:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
   48f50:	00ffff84 	movi	r3,-2
   48f54:	d0a00d17 	ldw	r2,-32716(gp)
   48f58:	194a183a 	rol	r5,r3,r5
   48f5c:	288a703a 	and	r5,r5,r2
   48f60:	d1600d15 	stw	r5,-32716(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   48f64:	d0a00d17 	ldw	r2,-32716(gp)
   48f68:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   48f6c:	2001703a 	wrctl	status,r4
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
   48f70:	0005883a 	mov	r2,zero
   48f74:	f800283a 	ret

00048f78 <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
   48f78:	000730fa 	rdctl	r3,ienable

    return (irq_enabled & (1 << irq)) ? 1: 0;
   48f7c:	00800044 	movi	r2,1
   48f80:	1144983a 	sll	r2,r2,r5
   48f84:	10c4703a 	and	r2,r2,r3
}
   48f88:	1004c03a 	cmpne	r2,r2,zero
   48f8c:	f800283a 	ret

00048f90 <alt_iic_isr_register>:
{
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
   48f90:	00c007c4 	movi	r3,31
   48f94:	19401616 	blt	r3,r5,48ff0 <alt_iic_isr_register+0x60>
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
   48f98:	defffe04 	addi	sp,sp,-8
   48f9c:	dfc00115 	stw	ra,4(sp)
   48fa0:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   48fa4:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   48fa8:	00ffff84 	movi	r3,-2
   48fac:	80c6703a 	and	r3,r16,r3
   48fb0:	1801703a 	wrctl	status,r3
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
   48fb4:	280490fa 	slli	r2,r5,3
   48fb8:	00c00174 	movhi	r3,5
   48fbc:	18e52504 	addi	r3,r3,-27500
   48fc0:	1885883a 	add	r2,r3,r2
   48fc4:	11800015 	stw	r6,0(r2)
    alt_irq[id].context = isr_context;
   48fc8:	11c00115 	stw	r7,4(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
   48fcc:	30000226 	beq	r6,zero,48fd8 <alt_iic_isr_register+0x48>
   48fd0:	0048f080 	call	48f08 <alt_ic_irq_enable>
   48fd4:	00000106 	br	48fdc <alt_iic_isr_register+0x4c>
   48fd8:	0048f400 	call	48f40 <alt_ic_irq_disable>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   48fdc:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
   48fe0:	dfc00117 	ldw	ra,4(sp)
   48fe4:	dc000017 	ldw	r16,0(sp)
   48fe8:	dec00204 	addi	sp,sp,8
   48fec:	f800283a 	ret
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  int rc = -EINVAL;  
   48ff0:	00bffa84 	movi	r2,-22
   48ff4:	f800283a 	ret

00048ff8 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
   48ff8:	000170fa 	wrctl	ienable,zero
   48ffc:	f800283a 	ret

00049000 <alt_exception_cause_generated_bad_addr>:
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
  switch (cause) {
   49000:	213ffe84 	addi	r4,r4,-6
   49004:	008003c4 	movi	r2,15
   49008:	11001636 	bltu	r2,r4,49064 <alt_exception_cause_generated_bad_addr+0x64>
   4900c:	200890ba 	slli	r4,r4,2
   49010:	00800174 	movhi	r2,5
   49014:	10a40904 	addi	r2,r2,-28636
   49018:	2089883a 	add	r4,r4,r2
   4901c:	20800017 	ldw	r2,0(r4)
   49020:	1000683a 	jmp	r2
   49024:	0004906c 	andhi	zero,zero,4673
   49028:	0004906c 	andhi	zero,zero,4673
   4902c:	00049064 	muli	zero,zero,4673
   49030:	00049064 	muli	zero,zero,4673
   49034:	00049064 	muli	zero,zero,4673
   49038:	0004906c 	andhi	zero,zero,4673
   4903c:	00049064 	muli	zero,zero,4673
   49040:	00049064 	muli	zero,zero,4673
   49044:	0004906c 	andhi	zero,zero,4673
   49048:	0004906c 	andhi	zero,zero,4673
   4904c:	00049064 	muli	zero,zero,4673
   49050:	0004906c 	andhi	zero,zero,4673
   49054:	00049064 	muli	zero,zero,4673
   49058:	00049064 	muli	zero,zero,4673
   4905c:	00049064 	muli	zero,zero,4673
   49060:	0004906c 	andhi	zero,zero,4673
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
   49064:	0005883a 	mov	r2,zero
   49068:	f800283a 	ret
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
   4906c:	00800044 	movi	r2,1
    return 0;

  default:
    return 0;
  }
}
   49070:	f800283a 	ret

00049074 <memcmp>:
   49074:	218d883a 	add	r6,r4,r6
   49078:	21800826 	beq	r4,r6,4909c <memcmp+0x28>
   4907c:	20800003 	ldbu	r2,0(r4)
   49080:	28c00003 	ldbu	r3,0(r5)
   49084:	10c00226 	beq	r2,r3,49090 <memcmp+0x1c>
   49088:	10c5c83a 	sub	r2,r2,r3
   4908c:	f800283a 	ret
   49090:	21000044 	addi	r4,r4,1
   49094:	29400044 	addi	r5,r5,1
   49098:	003ff706 	br	49078 <_gp+0xffff7c24>
   4909c:	0005883a 	mov	r2,zero
   490a0:	f800283a 	ret

000490a4 <memcpy>:
   490a4:	2005883a 	mov	r2,r4
   490a8:	2007883a 	mov	r3,r4
   490ac:	218d883a 	add	r6,r4,r6
   490b0:	19800526 	beq	r3,r6,490c8 <memcpy+0x24>
   490b4:	29000003 	ldbu	r4,0(r5)
   490b8:	18c00044 	addi	r3,r3,1
   490bc:	29400044 	addi	r5,r5,1
   490c0:	193fffc5 	stb	r4,-1(r3)
   490c4:	003ffa06 	br	490b0 <_gp+0xffff7c5c>
   490c8:	f800283a 	ret

000490cc <strlen>:
   490cc:	2005883a 	mov	r2,r4
   490d0:	10c00007 	ldb	r3,0(r2)
   490d4:	18000226 	beq	r3,zero,490e0 <strlen+0x14>
   490d8:	10800044 	addi	r2,r2,1
   490dc:	003ffc06 	br	490d0 <_gp+0xffff7c7c>
   490e0:	1105c83a 	sub	r2,r2,r4
   490e4:	f800283a 	ret

000490e8 <__divsi3>:
   490e8:	20001b16 	blt	r4,zero,49158 <__divsi3+0x70>
   490ec:	000f883a 	mov	r7,zero
   490f0:	28001616 	blt	r5,zero,4914c <__divsi3+0x64>
   490f4:	200d883a 	mov	r6,r4
   490f8:	29001a2e 	bgeu	r5,r4,49164 <__divsi3+0x7c>
   490fc:	00800804 	movi	r2,32
   49100:	00c00044 	movi	r3,1
   49104:	00000106 	br	4910c <__divsi3+0x24>
   49108:	10000d26 	beq	r2,zero,49140 <__divsi3+0x58>
   4910c:	294b883a 	add	r5,r5,r5
   49110:	10bfffc4 	addi	r2,r2,-1
   49114:	18c7883a 	add	r3,r3,r3
   49118:	293ffb36 	bltu	r5,r4,49108 <_gp+0xffff7cb4>
   4911c:	0005883a 	mov	r2,zero
   49120:	18000726 	beq	r3,zero,49140 <__divsi3+0x58>
   49124:	0005883a 	mov	r2,zero
   49128:	31400236 	bltu	r6,r5,49134 <__divsi3+0x4c>
   4912c:	314dc83a 	sub	r6,r6,r5
   49130:	10c4b03a 	or	r2,r2,r3
   49134:	1806d07a 	srli	r3,r3,1
   49138:	280ad07a 	srli	r5,r5,1
   4913c:	183ffa1e 	bne	r3,zero,49128 <_gp+0xffff7cd4>
   49140:	38000126 	beq	r7,zero,49148 <__divsi3+0x60>
   49144:	0085c83a 	sub	r2,zero,r2
   49148:	f800283a 	ret
   4914c:	014bc83a 	sub	r5,zero,r5
   49150:	39c0005c 	xori	r7,r7,1
   49154:	003fe706 	br	490f4 <_gp+0xffff7ca0>
   49158:	0109c83a 	sub	r4,zero,r4
   4915c:	01c00044 	movi	r7,1
   49160:	003fe306 	br	490f0 <_gp+0xffff7c9c>
   49164:	00c00044 	movi	r3,1
   49168:	003fee06 	br	49124 <_gp+0xffff7cd0>

0004916c <__modsi3>:
   4916c:	20001716 	blt	r4,zero,491cc <__modsi3+0x60>
   49170:	000f883a 	mov	r7,zero
   49174:	2005883a 	mov	r2,r4
   49178:	28001216 	blt	r5,zero,491c4 <__modsi3+0x58>
   4917c:	2900162e 	bgeu	r5,r4,491d8 <__modsi3+0x6c>
   49180:	01800804 	movi	r6,32
   49184:	00c00044 	movi	r3,1
   49188:	00000106 	br	49190 <__modsi3+0x24>
   4918c:	30000a26 	beq	r6,zero,491b8 <__modsi3+0x4c>
   49190:	294b883a 	add	r5,r5,r5
   49194:	31bfffc4 	addi	r6,r6,-1
   49198:	18c7883a 	add	r3,r3,r3
   4919c:	293ffb36 	bltu	r5,r4,4918c <_gp+0xffff7d38>
   491a0:	18000526 	beq	r3,zero,491b8 <__modsi3+0x4c>
   491a4:	1806d07a 	srli	r3,r3,1
   491a8:	11400136 	bltu	r2,r5,491b0 <__modsi3+0x44>
   491ac:	1145c83a 	sub	r2,r2,r5
   491b0:	280ad07a 	srli	r5,r5,1
   491b4:	183ffb1e 	bne	r3,zero,491a4 <_gp+0xffff7d50>
   491b8:	38000126 	beq	r7,zero,491c0 <__modsi3+0x54>
   491bc:	0085c83a 	sub	r2,zero,r2
   491c0:	f800283a 	ret
   491c4:	014bc83a 	sub	r5,zero,r5
   491c8:	003fec06 	br	4917c <_gp+0xffff7d28>
   491cc:	0109c83a 	sub	r4,zero,r4
   491d0:	01c00044 	movi	r7,1
   491d4:	003fe706 	br	49174 <_gp+0xffff7d20>
   491d8:	00c00044 	movi	r3,1
   491dc:	003ff106 	br	491a4 <_gp+0xffff7d50>

000491e0 <__udivsi3>:
   491e0:	200d883a 	mov	r6,r4
   491e4:	2900152e 	bgeu	r5,r4,4923c <__udivsi3+0x5c>
   491e8:	28001416 	blt	r5,zero,4923c <__udivsi3+0x5c>
   491ec:	00800804 	movi	r2,32
   491f0:	00c00044 	movi	r3,1
   491f4:	00000206 	br	49200 <__udivsi3+0x20>
   491f8:	10000e26 	beq	r2,zero,49234 <__udivsi3+0x54>
   491fc:	28000516 	blt	r5,zero,49214 <__udivsi3+0x34>
   49200:	294b883a 	add	r5,r5,r5
   49204:	10bfffc4 	addi	r2,r2,-1
   49208:	18c7883a 	add	r3,r3,r3
   4920c:	293ffa36 	bltu	r5,r4,491f8 <_gp+0xffff7da4>
   49210:	18000826 	beq	r3,zero,49234 <__udivsi3+0x54>
   49214:	0005883a 	mov	r2,zero
   49218:	31400236 	bltu	r6,r5,49224 <__udivsi3+0x44>
   4921c:	314dc83a 	sub	r6,r6,r5
   49220:	10c4b03a 	or	r2,r2,r3
   49224:	1806d07a 	srli	r3,r3,1
   49228:	280ad07a 	srli	r5,r5,1
   4922c:	183ffa1e 	bne	r3,zero,49218 <_gp+0xffff7dc4>
   49230:	f800283a 	ret
   49234:	0005883a 	mov	r2,zero
   49238:	f800283a 	ret
   4923c:	00c00044 	movi	r3,1
   49240:	003ff406 	br	49214 <_gp+0xffff7dc0>

00049244 <__umodsi3>:
   49244:	2005883a 	mov	r2,r4
   49248:	2900122e 	bgeu	r5,r4,49294 <__umodsi3+0x50>
   4924c:	28001116 	blt	r5,zero,49294 <__umodsi3+0x50>
   49250:	01800804 	movi	r6,32
   49254:	00c00044 	movi	r3,1
   49258:	00000206 	br	49264 <__umodsi3+0x20>
   4925c:	30000c26 	beq	r6,zero,49290 <__umodsi3+0x4c>
   49260:	28000516 	blt	r5,zero,49278 <__umodsi3+0x34>
   49264:	294b883a 	add	r5,r5,r5
   49268:	31bfffc4 	addi	r6,r6,-1
   4926c:	18c7883a 	add	r3,r3,r3
   49270:	293ffa36 	bltu	r5,r4,4925c <_gp+0xffff7e08>
   49274:	18000626 	beq	r3,zero,49290 <__umodsi3+0x4c>
   49278:	1806d07a 	srli	r3,r3,1
   4927c:	11400136 	bltu	r2,r5,49284 <__umodsi3+0x40>
   49280:	1145c83a 	sub	r2,r2,r5
   49284:	280ad07a 	srli	r5,r5,1
   49288:	183ffb1e 	bne	r3,zero,49278 <_gp+0xffff7e24>
   4928c:	f800283a 	ret
   49290:	f800283a 	ret
   49294:	00c00044 	movi	r3,1
   49298:	003ff706 	br	49278 <_gp+0xffff7e24>

0004929c <__mulsi3>:
   4929c:	0005883a 	mov	r2,zero
   492a0:	20000726 	beq	r4,zero,492c0 <__mulsi3+0x24>
   492a4:	20c0004c 	andi	r3,r4,1
   492a8:	2008d07a 	srli	r4,r4,1
   492ac:	18000126 	beq	r3,zero,492b4 <__mulsi3+0x18>
   492b0:	1145883a 	add	r2,r2,r5
   492b4:	294b883a 	add	r5,r5,r5
   492b8:	203ffa1e 	bne	r4,zero,492a4 <_gp+0xffff7e50>
   492bc:	f800283a 	ret
   492c0:	f800283a 	ret
